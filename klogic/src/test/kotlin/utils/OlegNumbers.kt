// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName")

package utils

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import utils.LogicInt.Companion.toLogic

val digitZero: Digit = 0.toLogic()
val digitOne: Digit = 1.toLogic()

typealias Digit = LogicInt
typealias OlegLogicNumber = LogicList<Digit>

val zero: OlegLogicNumber = logicListOf()
val one: OlegLogicNumber = logicListOf( 1.toLogic() )
val three: OlegLogicNumber = logicListOf( 1.toLogic(), 1.toLogic() )

fun UInt.toOlegLogicNumber(): OlegLogicNumber = toLogicList()
fun UInt.toLogicList(): LogicList<Digit> =
    when {
        this == 0u -> nilLogicList()
        this % 2u == 0u -> digitZero + (this / 2u).toLogicList()
        else -> digitOne + (this / 2u).toLogicList()
    }

fun <T> pause(f: () -> RecursiveStream<T>): RecursiveStream<T> = ThunkStream(f)


// There are 7 relations
fun poso(n: Term<LogicList<LogicInt>>): Goal =
  val h : int = freshTypedVar();
  val t : int = freshTypedVar();
  pause { (n `===` (h + t)) }
fun zeroo(n: Term<LogicList<LogicInt>>): Goal =
  (n `===` nilLogicList())
fun appendo(l: Term<LogicList<LogicInt>>, s: Term<LogicList<LogicInt>>,
out: Term<LogicList<LogicInt>>): Goal =
  conde(((l `===` nilLogicList()) and (s `===` out)),
  val a : int = freshTypedVar();
  val d : int = freshTypedVar();
  val res : int = freshTypedVar();
  pause { and(((a + d) `===` l), ((a + res) `===` out), appendo(d, s, res)) })
fun gt1o(n: Term<LogicList<LogicInt>>): Goal =
  val a : int = freshTypedVar();
  val ad : int = freshTypedVar();
  val dd : int = freshTypedVar();
  pause { (n `===` (a + (ad + dd))) }
fun full_addero(b: Term<LogicInt>, x: Term<LogicInt>, y: Term<LogicInt>,
r: Term<LogicInt>, c: Term<LogicInt>): Goal =
  conde((((((0.toLogic() `===` b) and (0.toLogic() `===` x)) and (0.toLogic() `===` y)) and (0.toLogic() `===` r)) and (0.toLogic() `===` c)),
  (((((1.toLogic() `===` b) and (0.toLogic() `===` x)) and (0.toLogic() `===` y)) and (1.toLogic() `===` r)) and (0.toLogic() `===` c)),
  (((((0.toLogic() `===` b) and (1.toLogic() `===` x)) and (0.toLogic() `===` y)) and (1.toLogic() `===` r)) and (0.toLogic() `===` c)),
  (((((1.toLogic() `===` b) and (1.toLogic() `===` x)) and (0.toLogic() `===` y)) and (0.toLogic() `===` r)) and (1.toLogic() `===` c)),
  (((((0.toLogic() `===` b) and (0.toLogic() `===` x)) and (1.toLogic() `===` y)) and (1.toLogic() `===` r)) and (0.toLogic() `===` c)),
  (((((1.toLogic() `===` b) and (0.toLogic() `===` x)) and (1.toLogic() `===` y)) and (0.toLogic() `===` r)) and (1.toLogic() `===` c)),
  (((((0.toLogic() `===` b) and (1.toLogic() `===` x)) and (1.toLogic() `===` y)) and (0.toLogic() `===` r)) and (1.toLogic() `===` c)),
  (((((1.toLogic() `===` b) and (1.toLogic() `===` x)) and (1.toLogic() `===` y)) and (1.toLogic() `===` r)) and (1.toLogic() `===` c)))
fun addero(d: Term<LogicInt>, n: Term<LogicList<LogicInt>>,
m: Term<LogicList<LogicInt>>, r: Term<LogicList<LogicInt>>): Goal =
  conde((((0.toLogic() `===` d) and (m `===` nilLogicList())) and (n `===` r)),
  ((((0.toLogic() `===` d) and (n `===` nilLogicList())) and (m `===` r)) and 
  poso(m)),
  (((1.toLogic() `===` d) and (m `===` nilLogicList())) and addero(0.toLogic(),
                                                            n, one, r)),
  ((((1.toLogic() `===` d) and (n `===` nilLogicList())) and poso(m)) and 
  addero(0.toLogic(), m, one, r)),
  (((n `===` one) and (m `===` one)) and val a : int = freshTypedVar();
                                         val c : int = freshTypedVar();
                                         pause { and(((a + (c + nilLogicList())) `===` r),
                                                 full_addero(d, 1.toLogic(),
                                                 1.toLogic(), a, c))
                                         }),
  ((n `===` one) and gen_addero(d, n, m, r)),
  ((((m `===` one) and gt1o(n)) and gt1o(r)) and addero(d, one, n, r)),
  (gt1o(n) and gen_addero(d, n, m, r)))
fun gen_addero(d: Term<LogicInt>, n: Term<LogicList<LogicInt>>,
m: Term<LogicList<LogicInt>>, r: Term<LogicList<LogicInt>>): Goal =
  OCanren.Fresh.five(/* ERROR ? */{|  fun a ->
                                        fun b ->
                                          fun c ->
                                            fun e ->
                                              fun x ->
                                                Fresh.two
                                                  (fun y ->
                                                     fun z ->
                                                       delay
                                                         (fun () ->
                                                            ?&
                                                              [(a % x) === n;
                                                              (b % y) === m;
                                                              poso y;
                                                              (c % z) === r;
                                                              poso z;
                                                              full_addero d a
                                                                b c e;
                                                              addero e x y z])) |})
// Put epilogue here 
