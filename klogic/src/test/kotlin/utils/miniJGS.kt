// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName")

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import utils.LogicInt
import utils.LogicOption
//import utils.None

typealias Decl = LogicInt
typealias JType = LogicInt

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }

// There are 7 relations
fun <ID : Term<ID>> dummy(typ: Term<Jtype<ID>>): Goal =
conde(freshTypedVars { a: Term<Jtype<ID>> -> (typ `===` Array_(a)) },
      freshTypedVars { a: Term<ID>, b: Term<LogicList<Targ<Jtype<ID>>>> ->
      (typ `===` Class_(a, b)) },
      freshTypedVars { a: Term<ID>, b: Term<PeanoLogic>, c: Term<Jtype<ID>>,
        d: Term<LogicOption<Jtype<ID>>> ->
      (typ `===` Var(a, b, c, d)) })
fun <ID : Term<ID>> substitute_typ(subst: (Term<LogicList<Targ<Jtype<ID>>>>) -> Term<Goal>,
q0: (Term<Jtype<ID>>) -> Term<Goal>, q30: Term<Jtype<ID>>): Goal =
freshTypedVars { q3: Term<Jtype<ID>> ->
and(q0(q3),
    conde(freshTypedVars { typ: Term<Jtype<ID>>, q4: Term<Jtype<ID>> ->
          and(q3 `===` Array_(typ),
              q30 `===` Array_(q4),
              substitute_typ(subst, {  eta-> typ `===` eta }, q4))
          },
          freshTypedVars { id: Term<ID>,
            args: Term<LogicList<Targ<Jtype<ID>>>>,
            q8: Term<LogicList<Targ<Jtype<ID>>>> ->
          and(q3 `===` Class_(id, args),
              q30 `===` Class_(id, q8),
              List_HO_map({  a,  b-> substitute_arg(subst, a, b) },
              {  eta-> eta `===` args }, q8))
          },
          freshTypedVars { id: Term<ID>,
            args: Term<LogicList<Targ<Jtype<ID>>>>,
            q13: Term<LogicList<Targ<Jtype<ID>>>> ->
          and(q3 `===` Interface(id, args),
              q30 `===` Interface(id, q13),
              List_HO_map({  a,  b-> substitute_arg(subst, a, b) },
              {  eta-> eta `===` args }, q13))
          },
          freshTypedVars { typs: Term<LogicList<Jtype<ID>>>,
            q17: Term<LogicList<Jtype<ID>>> ->
          and(q3 `===` Intersect(typs),
              q30 `===` Intersect(q17),
              List_HO_map({  a,  b-> substitute_typ(subst, a, b) },
              {  eta-> eta `===` typs }, q17))
          },
          pause { and(q3 `===` Null(/* Unit */),
                      q30 `===` Null(/* Unit */))
          }))
}
fun <ID : Term<ID>> substitute_arg(subst: (Term<LogicList<Targ<Jtype<ID>>>>) -> Term<Goal>,
q34: (Term<Targ<Jtype<ID>>>) -> Term<Goal>,
q63: Term<Targ<Jtype<ID>>>): Goal =
freshTypedVars { q37: Term<Targ> ->
and(q34(q37),
    conde(freshTypedVars { q38: Term<ID>, index: Term<PeanoLogic>,
            q39: Term<Jtype<ID>>, q40: Term<LogicOption<Jtype<ID>>> ->
          and(q37 `===` Type(Var(q38, index, q39, q40)),
              List_HO_nth(subst, {  eta-> eta `===` index }, q63))
          },
          freshTypedVars { typ: Term<Jtype<ID>>, q48: Term<Jtype<ID>> ->
          and(q37 `===` Type(typ),
              q63 `===` Type(q48),
              wc {__JGS_miniJGS_ml_c31 : Term<ID> ->
              wc {__JGS_miniJGS_ml_c34 : Term<PeanoLogic> ->
              wc {__JGS_miniJGS_ml_c37 : Term<Jtype<ID>> ->
              wc {__JGS_miniJGS_ml_c40 : Term<LogicOption<Jtype<ID>>> ->
              (q37 `!==` Type(Var(__JGS_miniJGS_ml_c31, __JGS_miniJGS_ml_c34,
                              __JGS_miniJGS_ml_c37, __JGS_miniJGS_ml_c40)))}}}},
              substitute_typ(subst, {  eta-> typ `===` eta }, q48))
          },
          pause { and(q37 `===` Wildcard(None()),
                      q63 `===` Wildcard(None()),
                      wc {__JGS_miniJGS_ml_c26 : Term<Jtype<ID>> ->
                      (q37 `!==` Type(__JGS_miniJGS_ml_c26))},
                      wc {__JGS_miniJGS_ml_c31 : Term<ID> ->
                      wc {__JGS_miniJGS_ml_c34 : Term<PeanoLogic> ->
                      wc {__JGS_miniJGS_ml_c37 : Term<Jtype<ID>> ->
                      wc {__JGS_miniJGS_ml_c40 : Term<LogicOption<Jtype<ID>>> ->
                      (q37 `!==` Type(Var(__JGS_miniJGS_ml_c31,
                                      __JGS_miniJGS_ml_c34,
                                      __JGS_miniJGS_ml_c37,
                                      __JGS_miniJGS_ml_c40)))}}}})
          },
          freshTypedVars { p: Term<Polarity>, typ: Term<Jtype<ID>>,
            q58: Term<Polarity>, q59: Term<Jtype<ID>> ->
          and(q37 `===` Wildcard(Some(LogicPair(p, typ))),
              q63 `===` Wildcard(Some(LogicPair(q58, q59))),
              p `===` q58,
              q37 `!==` Wildcard(None()),
              wc {__JGS_miniJGS_ml_c26 : Term<Jtype<ID>> ->
              (q37 `!==` Type(__JGS_miniJGS_ml_c26))},
              wc {__JGS_miniJGS_ml_c31 : Term<ID> ->
              wc {__JGS_miniJGS_ml_c34 : Term<PeanoLogic> ->
              wc {__JGS_miniJGS_ml_c37 : Term<Jtype<ID>> ->
              wc {__JGS_miniJGS_ml_c40 : Term<LogicOption<Jtype<ID>>> ->
              (q37 `!==` Type(Var(__JGS_miniJGS_ml_c31, __JGS_miniJGS_ml_c34,
                              __JGS_miniJGS_ml_c37, __JGS_miniJGS_ml_c40)))}}}},
              substitute_typ(subst, {  eta-> typ `===` eta }, q59))
          }))
}
// HIGH_ORDER 
interface HIGH_ORDER {
  // decl_by_id
  fun decl_by_id(v1: (Term< LogicInt >) -> Term<Goal>, v2: Term<Decl>
  ): Term<Goal>
  // get_superclass
  fun get_superclass(v3: (Term< LogicInt >) -> Term<Goal>,
  v4: (Term< LogicInt >) -> Term<Goal>,
  v5: Term<LogicOption<Jtype< LogicInt >>> ): Term<Goal>
  // object_t
  fun object_t(v6: Term<JType> ): Term<Goal>
  // cloneable_t
  fun cloneable_t(v7: Term<JType> ): Term<Goal>
  // serializable_t
  fun serializable_t(v8: Term<JType> ): Term<Goal>
  // new_var
  fun new_var(v9: Term< LogicInt > ): Term<Goal>
  }

// CLASS_TABLE 
interface CLASS_TABLE {
  val HO : HIGH_ORDER
  }

// VERIFIER 
interface VERIFIER {
  // appo
  fun appo(v1: (Term<A>) -> Term<Goal>, v2: Term<A> ): Term<Goal>
  }

// functor
private val Verifier : (CLASS_TABLE) -> VERIFIER = { CT: CLASS_TABLE ->
object: VERIFIER {
  fun <A : Term<A>> appo(f: (Term<A>) -> Term<Goal>, x: Term<A>): Goal =
  f(x)
// Put epilogue here 
}}
