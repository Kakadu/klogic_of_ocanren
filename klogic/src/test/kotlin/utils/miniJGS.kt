// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName"
  , "PropertyName", "ClassName", "LocalVariableName"
  )

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.*
import org.klogic.utils.terms.LogicBool.Companion.toLogicBool
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import utils.LogicInt
import utils.LogicInt.Companion.toLogic
import utils.Some
import utils.None
import utils.LogicOption
//import utils.None

typealias Decl = LogicInt
typealias JType = LogicInt

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }
@Suppress("UNUSED_PARAMETER")
fun <A: Term<A>> wc(f : (Term<A>) -> Goal ) : Goal = success

// There are 11 relations
fun <B : Term<B>, A : Term<A>> list_ho_map(f: ((Term<A>) -> Goal, Term<B>) -> Goal,
lst: (Term<LogicList<A>>) -> Goal, ys: Term<LogicList<B>>): Goal =
freshTypedVars { xs: Term<LogicList<A>> ->
and(lst(xs),
    conde(((xs `===` nilLogicList()) and (ys `===` nilLogicList())),
          freshTypedVars { h: Term<A>, tl: Term<LogicList<A>>, tmph: Term<B>,
            tmptl: Term<LogicList<B>> ->
          and(xs `===` (h + tl),
              ys `===` (tmph + tmptl),
              f({ eta: Term<A> -> eta `===` h }, tmph),
              list_ho_map(f, { eta: Term<LogicList<A>> -> eta `===` tl },
              tmptl))
          }))
}
fun <B : Term<B>> list_ho_nth(hoxs: (Term<LogicList<B>>) -> Goal,
hon: (Term<PeanoLogicNumber>) -> Goal, rez: Term<B>): Goal =
freshTypedVars { xs: Term<LogicList<B>>, n: Term<PeanoLogicNumber> ->
and(hoxs(xs),
    hon(n),
    conde(freshTypedVars { tl: Term<LogicList<B>> ->
          and(n `===` ZeroNaturalNumber,
              xs `===` (rez + tl))
          },
          freshTypedVars { prev: Term<PeanoLogicNumber>, h: Term<B>,
            tl: Term<LogicList<B>> ->
          and(n `===` NextNaturalNumber(prev),
              xs `===` (h + tl),
              list_ho_nth({ eta: Term<LogicList<B>> -> eta `===` tl },
              { eta: Term<PeanoLogicNumber> -> eta `===` prev }, rez))
          }))
}
fun <C : Term<C>, B : Term<B>, A : Term<A>> list_ho_fold_left2(f: ((Term<A>) -> Goal, 
                                                                  (Term<B>) -> Goal, 
                                                                  (Term<C>) -> Goal, Term<A>) -> Goal,
acc: (Term<A>) -> Goal, l1: (Term<LogicList<B>>) -> Goal,
l2: (Term<LogicList<C>>) -> Goal, q223: Term<A>): Goal =
freshTypedVars { q209: Term</* (('b OCanren.ilogic,
                                 'b OCanren.ilogic OCanren.Std.List.injected)
                                OCanren.Std.List.t OCanren__.Logic.ilogic *
                                ('c OCanren.ilogic,
                                 'c OCanren.ilogic OCanren.Std.List.injected)
                                OCanren.Std.List.t OCanren__.Logic.ilogic)
                               OCanren__.Logic.ilogic */Error< /*('b OCanren.ilogic, 'b OCanren.ilogic OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic *('c OCanren.ilogic, 'c OCanren.ilogic OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic 111 */>>,
  q205: Term<LogicList<B>>, q206: Term<LogicList<C>> ->
and(q209 `===` LogicPair(q205, q206),
    l1(q205),
    l2(q206),
    conde(((q209 `===` LogicPair(OCanren.exclamation_exclamation({| Other 
                                                                 OCanren.Std.List.Nil |}),
                       OCanren.exclamation_exclamation({| Other OCanren.Std.List.Nil |}))) and 
          acc(q223)),
          freshTypedVars { hd1: Term<B>, tl1: Term<LogicList<B>>,
            hd2: Term<C>, tl2: Term<LogicList<C>> ->
          and(q209 `===` LogicPair(OCanren.exclamation_exclamation({| Other 
                                                                   OCanren.Std.List.Cons
                                                                    (hd1,
                                                                    tl1) |}),
                         OCanren.exclamation_exclamation({| Other OCanren.Std.List.Cons
                                                                    (hd2,
                                                                    tl2) |})),
              list_ho_fold_left2(f,
              f(acc, { q210: Term<B> -> hd1 `===` q210 },
              { q212: Term<C> -> hd2 `===` q212 }),
              { q211: Term<LogicList<B>> -> tl1 `===` q211 },
              { q213: Term<LogicList<C>> -> tl2 `===` q213 }, q223))
          },
          OCanren_dot_failure))
}
fun <ID : Term<ID>> substitute_typ(subst: (Term<LogicList<Jarg<Jtype<ID>>>>) -> Goal,
q0: (Term<Jtype<ID>>) -> Goal, q30: Term<Jtype<ID>>): Goal =
freshTypedVars { q3: Term<Jtype<ID>> ->
and(q0(q3),
    conde(freshTypedVars { typ: Term<Jtype<ID>>, q4: Term<Jtype<ID>> ->
          and(q3 `===` Array_(typ),
              q30 `===` Array_(q4),
              substitute_typ(subst,
              { eta: Term<Jtype<ID>> -> typ `===` eta }, q4))
          },
          freshTypedVars { id: Term<ID>,
            args: Term<LogicList<Jarg<Jtype<ID>>>>,
            q8: Term<LogicList<Jarg<Jtype<ID>>>> ->
          and(q3 `===` Class_(id, args),
              q30 `===` Class_(id, q8),
              list_ho_map({ a: (Term<Jarg<Jtype<ID>>>) -> Goal, b: Term<Jarg<Jtype<ID>>> -> 
                          substitute_arg(subst, a, b) },
              { eta: Term<LogicList<Jarg<Jtype<ID>>>> -> eta `===` args },
              q8))
          },
          freshTypedVars { id: Term<ID>,
            args: Term<LogicList<Jarg<Jtype<ID>>>>,
            q13: Term<LogicList<Jarg<Jtype<ID>>>> ->
          and(q3 `===` Interface(id, args),
              q30 `===` Interface(id, q13),
              list_ho_map({ a: (Term<Jarg<Jtype<ID>>>) -> Goal, b: Term<Jarg<Jtype<ID>>> -> 
                          substitute_arg(subst, a, b) },
              { eta: Term<LogicList<Jarg<Jtype<ID>>>> -> eta `===` args },
              q13))
          },
          freshTypedVars { typs: Term<LogicList<Jtype<ID>>>,
            q17: Term<LogicList<Jtype<ID>>> ->
          and(q3 `===` Intersect(typs),
              q30 `===` Intersect(q17),
              list_ho_map({ a: (Term<Jtype<ID>>) -> Goal, b: Term<Jtype<ID>> -> 
                          substitute_typ(subst, a, b) },
              { eta: Term<LogicList<Jtype<ID>>> -> eta `===` typs }, q17))
          },
          pause { and(q3 `===` Null(/* Unit */),
                      q30 `===` Null(/* Unit */))
          }))
}
fun <ID : Term<ID>> substitute_arg(subst: (Term<LogicList<Jarg<Jtype<ID>>>>) -> Goal,
q34: (Term<Jarg<Jtype<ID>>>) -> Goal, q63: Term<Jarg<Jtype<ID>>>): Goal =
freshTypedVars { q37: Term<Jarg<Jtype<ID>>> ->
and(q34(q37),
    conde(freshTypedVars { q38: Term<ID>, index: Term<PeanoLogicNumber>,
            q39: Term<Jtype<ID>>, q40: Term<LogicOption<Jtype<ID>>> ->
          and(q37 `===` Type(Var(q38, index, q39, q40)),
              list_ho_nth(subst,
              { eta: Term<PeanoLogicNumber> -> eta `===` index }, q63))
          },
          freshTypedVars { typ: Term<Jtype<ID>>, q48: Term<Jtype<ID>> ->
          and(q37 `===` Type(typ),
              q63 `===` Type(q48),
              substitute_typ(subst,
              { eta: Term<Jtype<ID>> -> typ `===` eta }, q48))
          },
          pause { and(q37 `===` Wildcard(None()),
                      q63 `===` Wildcard(None()),
                      wc {__JGS_miniJGS_ml_c26 : Term<Jtype<ID>> ->
                      (q37 `!==` Type(__JGS_miniJGS_ml_c26))},
                      wc {__JGS_miniJGS_ml_c31 : Term<ID> ->
                      wc {__JGS_miniJGS_ml_c34 : Term<PeanoLogicNumber> ->
                      wc {__JGS_miniJGS_ml_c37 : Term<Jtype<ID>> ->
                      wc {__JGS_miniJGS_ml_c40 : Term<LogicOption<Jtype<ID>>> ->
                      (q37 `!==` Type(Var(__JGS_miniJGS_ml_c31,
                                      __JGS_miniJGS_ml_c34,
                                      __JGS_miniJGS_ml_c37,
                                      __JGS_miniJGS_ml_c40)))}}}})
          },
          freshTypedVars { p: Term<Polarity/*228*/>, typ: Term<Jtype<ID>>,
            q58: Term<Polarity/*228*/>, q59: Term<Jtype<ID>> ->
          and(q37 `===` Wildcard(Some(LogicPair(p, typ))),
              q63 `===` Wildcard(Some(LogicPair(q58, q59))),
              p `===` q58,
              q37 `!==` Wildcard(None()),
              wc {__JGS_miniJGS_ml_c26 : Term<Jtype<ID>> ->
              (q37 `!==` Type(__JGS_miniJGS_ml_c26))},
              substitute_typ(subst,
              { eta: Term<Jtype<ID>> -> typ `===` eta }, q59))
          }))
}
// HIGH_ORDER 
interface HIGH_ORDER {
  // decl_by_id
  fun decl_by_id(v1: (Term<LogicInt>) -> Goal, v2: Term<Decl> ): Goal
  // get_superclass
  fun get_superclass(v3: (Term<LogicInt>) -> Goal,
  v4: (Term<LogicInt>) -> Goal, v5: Term<LogicOption<Jtype<LogicInt>>>
  ): Goal
  // object_t
  fun object_t(v6: Term<JType> ): Goal
  // cloneable_t
  fun cloneable_t(v7: Term<JType> ): Goal
  // serializable_t
  fun serializable_t(v8: Term<JType> ): Goal
  // new_var
  fun new_var(v9: Term<LogicInt> ): Goal
  }

// CLASS_TABLE 
interface CLASS_TABLE {
  val HO : HIGH_ORDER
  }

// VERIFIER 
interface VERIFIER {
  // appo
  fun<A : Term<A>> appo(v1: (Term<A>) -> Goal, v2: Term<A> ): Goal
  }

// functor
private val Verifier : (CLASS_TABLE) -> VERIFIER = { CT: CLASS_TABLE ->
object: VERIFIER {
  override fun <A : Term<A>> appo(f: (Term<A>) -> Goal, x: Term<A>): Goal =
  f(x)
}}
fun  test_int(x: Term<LogicInt>): Goal =
conde(x `===` 1.toLogic(),
      x `===` 2.toLogic())
fun  test_bool(x: Term<LogicBool>): Goal =
conde(x `===` true.toLogicBool(),
      x `===` false.toLogicBool())
// Put epilogue here 
