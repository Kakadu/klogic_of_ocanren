// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName")

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import org.klogic.utils.terms.PeanoLogicNumber
import org.klogic.utils.terms.NextNaturalNumber
import org.klogic.utils.terms.ZeroNaturalNumber
import utils.LogicInt
import utils.LogicOption
//import utils.None

typealias Decl = LogicInt
typealias JType = LogicInt

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }

// There are 9 relations
fun <B : Term<B>, A : Term<A>> list_ho_map(f: ((Term<A>) -> Goal, Term<B>) -> Goal,
lst: (Term<LogicList<A>>) -> Goal, ys: Term<LogicList<B>>): Goal =
freshTypedVars { xs: Term<LogicList<A>> ->
and(lst(xs),
    conde(((xs `===` nilLogicList()) and (ys `===` nilLogicList())),
          freshTypedVars { h: Term<A>, tl: Term<LogicList<A>>, tmph: Term<B>,
            tmptl: Term<LogicList<B>> ->
          and(xs `===` (h + tl),
              ys `===` (tmph + tmptl),
              f({  eta-> eta `===` h }, tmph),
              list_ho_map(f, {  eta-> eta `===` tl }, tmptl))
          }))
}
fun <B : Term<B>> list_ho_nth(hoxs: (Term<LogicList<B>>) -> Goal,
hon: (Term<PeanoLogicNumber>) -> Goal, rez: Term<B>): Goal =
freshTypedVars { xs: Term<LogicList<B>>, n: Term<PeanoLogicNumber/**/> ->
and(hoxs(xs),
    hon(n),
    conde(freshTypedVars { tl: Term<LogicList<B>> ->
          and(n `===` ZeroNaturalNumber,
              xs `===` (rez + tl))
          },
          freshTypedVars { prev: Term<PeanoLogicNumber/**/>, h: Term<B>,
            tl: Term<LogicList<B>> ->
          and(n `===` NextNaturalNumber(prev),
              xs `===` (h + tl),
              list_ho_nth({  eta-> eta `===` tl }, {  eta-> eta `===` prev },
              rez))
          }))
}
fun <ID : Term<ID>> dummy(typ: Term<Jtype<ID>>): Goal =
conde(freshTypedVars { a: Term<Jtype<ID>> -> (typ `===` Array_(a)) },
      freshTypedVars { a: Term<ID>, b: Term<LogicList<Targ<Jtype<ID>>>> ->
      (typ `===` Class_(a, b)) },
      freshTypedVars { a: Term<ID>, b: Term<PeanoLogicNumber/**/>,
        c: Term<Jtype<ID>>, d: Term<LogicOption<Jtype<ID>>> ->
      (typ `===` Var(a, b, c, d)) })
fun <ID : Term<ID>> substitute_typ(subst: (Term<LogicList<Targ<Jtype<ID>>>>) -> Goal,
q0: (Term<Jtype<ID>>) -> Goal, q30: Term<Jtype<ID>>): Goal =
freshTypedVars { q3: Term<Jtype<ID>> ->
and(q0(q3),
    conde(freshTypedVars { typ: Term<Jtype<ID>>, q4: Term<Jtype<ID>> ->
          and(q3 `===` Array_(typ),
              q30 `===` Array_(q4),
              substitute_typ(subst, {  eta-> typ `===` eta }, q4))
          },
          freshTypedVars { id: Term<ID>,
            args: Term<LogicList<Targ<Jtype<ID>>>>,
            q8: Term<LogicList<Targ<Jtype<ID>>>> ->
          and(q3 `===` Class_(id, args),
              q30 `===` Class_(id, q8),
              list_ho_map({ (a: (Term<Targ<Jtype<ID>>>) -> Goal, b: Term<Targ<Jtype<ID>>>) ->
                  substitute_arg(subst, a, b) },
              {  eta-> eta `===` args }, q8))
          },
          freshTypedVars { id: Term<ID>,
            args: Term<LogicList<Targ<Jtype<ID>>>>,
            q13: Term<LogicList<Targ<Jtype<ID>>>> ->
          and(q3 `===` Interface(id, args),
              q30 `===` Interface(id, q13),
              list_ho_map({  (a: (Term<Targ<Jtype<ID>>>) -> Goal, b) ->
                    substitute_arg(subst, a, b) },
              {  eta-> eta `===` args }, q13))
          },
          freshTypedVars { typs: Term<LogicList<Jtype<ID>>>,
            q17: Term<LogicList<Jtype<ID>>> ->
          and(q3 `===` Intersect(typs),
              q30 `===` Intersect(q17),
              list_ho_map({  a,  b-> substitute_typ(subst, a, b) },
              {  eta-> eta `===` typs }, q17))
          },
          pause { and(q3 `===` Null(/* Unit */),
                      q30 `===` Null(/* Unit */))
          }))
}
fun <ID : Term<ID>> substitute_arg(subst: (Term<LogicList<Targ<Jtype<ID>>>>) -> Goal,
q34: (Term<Targ<Jtype<ID>>>) -> Goal, q63: Term<Targ<Jtype<ID>>>): Goal =
freshTypedVars { q37: Term<Targ> ->
and(q34(q37),
    conde(freshTypedVars { q38: Term<ID>, index: Term<PeanoLogicNumber/**/>,
            q39: Term<Jtype<ID>>, q40: Term<LogicOption<Jtype<ID>>> ->
          and(q37 `===` Type(Var(q38, index, q39, q40)),
              list_ho_nth(subst, {  eta-> eta `===` index }, q63))
          },
          freshTypedVars { typ: Term<Jtype<ID>>, q48: Term<Jtype<ID>> ->
          and(q37 `===` Type(typ),
              q63 `===` Type(q48),
              wc {__JGS_miniJGS_ml_c31 : Term<ID> ->
              wc {__JGS_miniJGS_ml_c34 : Term<PeanoLogicNumber/**/> ->
              wc {__JGS_miniJGS_ml_c37 : Term<Jtype<ID>> ->
              wc {__JGS_miniJGS_ml_c40 : Term<LogicOption<Jtype<ID>>> ->
              (q37 `!==` Type(Var(__JGS_miniJGS_ml_c31, __JGS_miniJGS_ml_c34,
                              __JGS_miniJGS_ml_c37, __JGS_miniJGS_ml_c40)))}}}},
              substitute_typ(subst, {  eta-> typ `===` eta }, q48))
          },
          pause { and(q37 `===` Wildcard(None()),
                      q63 `===` Wildcard(None()),
                      wc {__JGS_miniJGS_ml_c26 : Term<Jtype<ID>> ->
                      (q37 `!==` Type(__JGS_miniJGS_ml_c26))},
                      wc {__JGS_miniJGS_ml_c31 : Term<ID> ->
                      wc {__JGS_miniJGS_ml_c34 : Term<PeanoLogicNumber/**/> ->
                      wc {__JGS_miniJGS_ml_c37 : Term<Jtype<ID>> ->
                      wc {__JGS_miniJGS_ml_c40 : Term<LogicOption<Jtype<ID>>> ->
                      (q37 `!==` Type(Var(__JGS_miniJGS_ml_c31,
                                      __JGS_miniJGS_ml_c34,
                                      __JGS_miniJGS_ml_c37,
                                      __JGS_miniJGS_ml_c40)))}}}})
          },
          freshTypedVars { p: Term<Polarity>, typ: Term<Jtype<ID>>,
            q58: Term<Polarity>, q59: Term<Jtype<ID>> ->
          and(q37 `===` Wildcard(Some(LogicPair(p, typ))),
              q63 `===` Wildcard(Some(LogicPair(q58, q59))),
              p `===` q58,
              q37 `!==` Wildcard(None()),
              wc {__JGS_miniJGS_ml_c26 : Term<Jtype<ID>> ->
              (q37 `!==` Type(__JGS_miniJGS_ml_c26))},
              wc {__JGS_miniJGS_ml_c31 : Term<ID> ->
              wc {__JGS_miniJGS_ml_c34 : Term<PeanoLogicNumber/**/> ->
              wc {__JGS_miniJGS_ml_c37 : Term<Jtype<ID>> ->
              wc {__JGS_miniJGS_ml_c40 : Term<LogicOption<Jtype<ID>>> ->
              (q37 `!==` Type(Var(__JGS_miniJGS_ml_c31, __JGS_miniJGS_ml_c34,
                              __JGS_miniJGS_ml_c37, __JGS_miniJGS_ml_c40)))}}}},
              substitute_typ(subst, {  eta-> typ `===` eta }, q59))
          }))
}
// HIGH_ORDER
interface HIGH_ORDER {
  // decl_by_id
  fun decl_by_id(v1: (Term< LogicInt >) -> Goal, v2: Term<Decl> ): Goal
  // get_superclass
  fun get_superclass(v3: (Term< LogicInt >) -> Goal,
  v4: (Term< LogicInt >) -> Goal, v5: Term<LogicOption<Jtype< LogicInt >>>
  ): Goal
  // object_t
  fun object_t(v6: Term<JType> ): Goal
  // cloneable_t
  fun cloneable_t(v7: Term<JType> ): Goal
  // serializable_t
  fun serializable_t(v8: Term<JType> ): Goal
  // new_var
  fun new_var(v9: Term< LogicInt > ): Goal
  }

// CLASS_TABLE
interface CLASS_TABLE {
  val HO : HIGH_ORDER
  }

// VERIFIER
interface VERIFIER {
  // appo
  fun appo(v1: (Term<A>) -> Goal, v2: Term<A> ): Goal
  }

// functor
private val Verifier : (CLASS_TABLE) -> VERIFIER = { CT: CLASS_TABLE ->
object: VERIFIER {
  fun <A : Term<A>> appo(f: (Term<A>) -> Goal, x: Term<A>): Goal =
  f(x)
// Put epilogue here
}}
