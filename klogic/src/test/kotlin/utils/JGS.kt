// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName"
  , "PropertyName", "ClassName", "LocalVariableName", "SpellCheckingInspection"
  , "PARAMETER_NAME_CHANGED_ON_OVERRIDE", "NAME_SHADOWING"
  )

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.*
import org.klogic.utils.terms.LogicBool.Companion.toLogicBool
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import utils.LogicInt
import utils.LogicInt.Companion.toLogic
import utils.Some
import utils.None
import utils.LogicOption

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

context(RelationalContext)
fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }

context(RelationalContext)
fun <A: Term<A>> wc(f : (Term<A>) -> Goal ) : Goal = f(wildcard())

// short alias for fresh type variables uses only one (i.e. wildcards in unifications)
context(RelationalContext)
fun <A: Term<A>> _f(): Term<A> = freshTypedVar()

// There are 12 relations
context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapo(f: (Term<A>, Term<B>) -> Goal,
      l: Term<LogicList<A>>, res: Term<LogicList<B>>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` nilLogicList()),
        freshTypedVars { l_hd: Term<A>, l_tl: Term<LogicList<A>>,
          res_hd: Term<B>, res_tl: Term<LogicList<B>> ->
        and(l `===` (l_hd + l_tl),
            res `===` (res_hd + res_tl),
            f(l_hd, res_hd),
            mapo(f, l_tl, res_tl))
        })

context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapio_helper(f: (Term<PeanoLogicNumber>, Term<A>, Term<B>) -> Goal,
      i: Term<PeanoLogicNumber>, l: Term<LogicList<A>>,
      res: Term<LogicList<B>>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` nilLogicList()),
        freshTypedVars { l_hd: Term<A>, l_tl: Term<LogicList<A>>,
          res_hd: Term<B>, res_tl: Term<LogicList<B>> ->
        and(l `===` (l_hd + l_tl),
            res `===` (res_hd + res_tl),
            f(i, l_hd, res_hd),
            mapio_helper(f, NextNaturalNumber(i), l_tl, res_tl))
        })

context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapio(f: (Term<PeanoLogicNumber>, Term<A>, Term<B>) -> Goal,
      l: Term<LogicList<A>>, res: Term<LogicList<B>>): Goal =
  mapio_helper(f, ZeroNaturalNumber, l, res)

context(RelationalContext)
fun <A : Term<A>> memo(e: Term<A>, l: Term<LogicList<A>>,
      res: Term<LogicBool>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` false.toLogicBool()),
        freshTypedVars { hd: Term<A>, tl: Term<LogicList<A>> ->
        and(l `===` (hd + tl),
            conde(and(hd `===` e,
                      res `===` true.toLogicBool()),
                  and(hd `!==` e,
                      memo(e, tl, res))))
        })

context(RelationalContext)
fun <A : Term<A>> ntho(l: Term<LogicList<A>>, n: Term<PeanoLogicNumber>,
      rez: Term<A>): Goal =
  freshTypedVars { hd: Term<A>, tl: Term<LogicList<A>> ->
  and(l `===` (hd + tl),
      conde(and(n `===` ZeroNaturalNumber,
                hd `===` rez),
            freshTypedVars { prev: Term<PeanoLogicNumber> ->
            and(n `===` NextNaturalNumber(prev),
                ntho(tl, prev, rez))
            }))
  }

context(RelationalContext)
fun <A : Term<A>> for_allo(p: (Term<A>, Term<LogicBool>) -> Goal,
      l: Term<LogicList<A>>, res: Term<LogicBool>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` true.toLogicBool()),
        freshTypedVars { hd: Term<A>, tl: Term<LogicList<A>>,
          p_res: Term<LogicBool> ->
        and(l `===` (hd + tl),
            p(hd, p_res),
            conde(and(p_res `===` true.toLogicBool(),
                      for_allo(p, tl, res)),
                  and(p_res `===` false.toLogicBool(),
                      res `===` false.toLogicBool())))
        })

context(RelationalContext)
fun <C : Term<C>, B : Term<B>, A : Term<A>> fold_left2o(f: (Term<A>, Term<B>, Term<C>, Term<A>) -> Goal,
      acc: Term<A>, l1: Term<LogicList<B>>, l2: Term<LogicList<C>>,
      res: Term<A>): Goal =
  conde(and(l1 `===` nilLogicList(),
            l2 `===` nilLogicList(),
            res `===` acc),
        freshTypedVars { hd1: Term<B>, tl1: Term<LogicList<B>>, hd2: Term<C>,
          tl2: Term<LogicList<C>>, new_acc: Term<A> ->
        and(l1 `===` (hd1 + tl1),
            l2 `===` (hd2 + tl2),
            f(acc, hd1, hd2, new_acc),
            fold_left2o(f, new_acc, tl1, tl2, res))
        })

context(RelationalContext)
fun <ID : Term<ID>> substitute_typ(subst: Term<LogicList<Jarg<Jtype<ID>>>>,
      typ: Term<Jtype<ID>>, res: Term<Jtype<ID>>): Goal =
  conde(freshTypedVars { param: Term<Jtype<ID>>,
          new_param: Term<Jtype<ID>> ->
        and(typ `===` Array_(param),
            res `===` Array_(new_param),
            substitute_typ(subst, param, new_param))
        },
        freshTypedVars { id: Term<ID>,
          args: Term<LogicList<Jarg<Jtype<ID>>>>,
          new_args: Term<LogicList<Jarg<Jtype<ID>>>> ->
        and(typ `===` Class_(id, args),
            res `===` Class_(id, new_args),
            mapo({ targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>> -> 
                 substitute_arg(subst, targ, res) },
            args, new_args))
        },
        freshTypedVars { id: Term<ID>,
          args: Term<LogicList<Jarg<Jtype<ID>>>>,
          new_args: Term<LogicList<Jarg<Jtype<ID>>>> ->
        and(typ `===` Interface(id, args),
            res `===` Interface(id, new_args),
            mapo({ targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>> -> 
                 substitute_arg(subst, targ, res) },
            args, new_args))
        },
        freshTypedVars { typs: Term<LogicList<Jtype<ID>>>,
          new_typs: Term<LogicList<Jtype<ID>>> ->
        and(typ `===` Intersect(typs),
            res `===` Intersect(new_typs),
            mapo({ typ: Term<Jtype<ID>>, res: Term<Jtype<ID>> -> substitute_typ(subst,
                                                                 typ, res) },
            typs, new_typs))
        },
        and(typ `===` Null(),
            res `===` Null()))

context(RelationalContext)
fun <ID : Term<ID>> substitute_arg(subst: Term<LogicList<Jarg<Jtype<ID>>>>,
      targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>>): Goal =
  conde(freshTypedVars { index: Term<PeanoLogicNumber> ->
        and((targ `===` Type(Var(_f(), index, _f(), _f()))),
            ntho(subst, index, res))
        },
        freshTypedVars { typ: Term<Jtype<ID>>, new_typ: Term<Jtype<ID>> ->
        and(targ `===` Type(typ),
            res `===` Type(new_typ),
            substitute_typ(subst, typ, new_typ))
        },
        and(targ `===` Wildcard(None()),
            res `===` Wildcard(None())),
        freshTypedVars { p: Term<Polarity/*94*/>, typ: Term<Jtype<ID>>,
          new_typ: Term<Jtype<ID>> ->
        and(targ `===` Wildcard(Some(LogicPair(p, typ))),
            res `===` Wildcard(Some(LogicPair(p, new_typ))),
            substitute_typ(subst, typ, new_typ))
        })

// CLASSTABLE 
interface CLASSTABLE {
  
  context(RelationalContext)
  fun decl_by_id(v1: Term<LogicInt>, v2: Term<Decl<LogicInt>> ): Goal
  
  context(RelationalContext)
  fun get_superclass_by_id(v3: Term<LogicInt>, v4: Term<LogicInt>,
  v5: Term<LogicOption<Jtype<LogicInt>>> ): Goal
  
  val object_t : Term<Jtype<LogicInt>>
  
  val cloneable_t : Term<Jtype<LogicInt>>
  
  val serializable_t : Term<Jtype<LogicInt>>
  
  context(RelationalContext)
  fun new_var( ): Term<LogicInt>
  }

// VERIFIER 
interface VERIFIER {
  
  context(RelationalContext)
  fun params(v1: Term<LogicInt>, v2: Term<LogicList<Jtype<LogicInt>>> ): Goal
  
  context(RelationalContext)
  fun raw_helper(v3: Term<LogicInt>, v4: Term<PeanoLogicNumber>,
  v5: Term<Jarg<Jtype<LogicInt>>>, v6: Term<ClosureConversionType<LogicInt>>
  ): Goal
  
  context(RelationalContext)
  fun subst_helper(v7: Term<ClosureConversionType<LogicInt>>,
  v8: Term<Jarg<Jtype<LogicInt>>> ): Goal
  
  context(RelationalContext)
  fun targs_helper(v9: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v10: Term<ClosureConversionType<LogicInt>>,
  v11: Term<Jarg<Jtype<LogicInt>>> ): Goal
  
  context(RelationalContext)
  fun targs_pred(
  v12: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v13: Term<Jarg<Jtype<LogicInt>>>, v14: Term<LogicBool> ): Goal
  
  context(RelationalContext)
  fun capture_conversion(
  v15: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v16: Term<LogicInt>, v17: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v18: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ): Goal
  
  context(RelationalContext)
  fun less_equal_less(
  v19: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v20: Term<Jarg<Jtype<LogicInt>>>, v21: Term<Jarg<Jtype<LogicInt>>>,
  v22: Term<LogicBool> ): Goal
  
  context(RelationalContext)
  fun class_int_sub(
  v23: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v24: Term<LogicInt>, v25: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v26: Term<LogicInt>, v27: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v28: Term<LogicBool> ): Goal
  
  context(RelationalContext)
  fun minus_less_minus(
  v29: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v30: Term<Jtype<LogicInt>>, v31: Term<Jtype<LogicInt>>,
  v32: Term<LogicBool> ): Goal
  }

// functor
val Verifier : (CLASSTABLE) -> VERIFIER = { CT: CLASSTABLE ->
object: VERIFIER {
  context(RelationalContext)
  override fun  params(id: Term<LogicInt>,
        p: Term<LogicList<Jtype<LogicInt>>>): Goal =
    freshTypedVars { decl: Term<Decl<LogicInt>> ->
    and(CT.decl_by_id(id, decl),
        conde((decl `===` C(p, _f(), _f())),
              (decl `===` I(p, _f()))))
    }
  
  
  context(RelationalContext)
  override fun  raw_helper(id: Term<LogicInt>, i: Term<PeanoLogicNumber>,
        targ: Term<Jarg<Jtype<LogicInt>>>,
        cc_targ: Term<ClosureConversionType<LogicInt>>): Goal =
    conde(freshTypedVars { t: Term<Jtype<LogicInt>> ->
          and(targ `===` Type(t),
              cc_targ `===` CC_type(t))
          },
          freshTypedVars { param: Term<Jtype<LogicInt>>,
            params_val: Term<LogicList<Jtype<LogicInt>>> ->
          and(targ `===` Wildcard(None()),
              cc_targ `===` CC_var(CT.new_var(), i, CC_subst(param),
                            Some(Null())),
              params(id, params_val),
              ntho(params_val, i, param))
          },
          freshTypedVars { t: Term<Jtype<LogicInt>>,
            subst: Term<Jtype<LogicInt>>,
            params_val: Term<LogicList<Jtype<LogicInt>>> ->
          and(targ `===` Wildcard(Some(LogicPair(Super(), t))),
              cc_targ `===` CC_var(CT.new_var(), i, CC_subst(subst), Some(t)),
              params(id, params_val),
              ntho(params_val, i, subst))
          },
          freshTypedVars { t: Term<Jtype<LogicInt>>,
            t2: Term<Jtype<LogicInt>>,
            params_val: Term<LogicList<Jtype<LogicInt>>> ->
          and(targ `===` Wildcard(Some(LogicPair(Extends(), t))),
              cc_targ `===` CC_var(CT.new_var(), i, CC_subst.cc_inter(t, t2),
                            Some(Null())),
              params(id, params_val),
              ntho(params_val, i, t2))
          })
  
  
  context(RelationalContext)
  override fun  subst_helper(raw_element: Term<ClosureConversionType<LogicInt>>,
        targ: Term<Jarg<Jtype<LogicInt>>>): Goal =
    conde(freshTypedVars { t: Term<Jtype<LogicInt>> ->
          and(raw_element `===` CC_type(t),
              targ `===` Type(t))
          },
          freshTypedVars { id: Term<LogicInt>, i: Term<PeanoLogicNumber> ->
          and((raw_element `===` CC_var(id, i, _f(), _f())),
              targ `===` Type(Var(id, i, Null(), None())))
          })
  
  
  context(RelationalContext)
  override fun  targs_helper(subst: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        cc_typ: Term<ClosureConversionType<LogicInt>>,
        res: Term<Jarg<Jtype<LogicInt>>>): Goal =
    conde(freshTypedVars { t: Term<Jtype<LogicInt>>,
            new_t: Term<Jtype<LogicInt>> ->
          and(cc_typ `===` CC_type(t),
              res `===` Type(new_t),
              substitute_typ(subst, t, new_t))
          },
          freshTypedVars { id: Term<LogicInt>, i: Term<PeanoLogicNumber>,
            p: Term<Jtype<LogicInt>>, new_p: Term<Jtype<LogicInt>>,
            lwb: Term<LogicOption<Jtype<LogicInt>>> ->
          and(cc_typ `===` CC_var(id, i, CC_subst(p), lwb),
              res `===` Type(Var(id, i, new_p, lwb)),
              substitute_typ(subst, p, new_p))
          },
          freshTypedVars { id : Term<LogicInt>,  i : Term<PeanoLogicNumber>,
           t : Term<Jtype<LogicInt>>,  p : Term<Jtype<LogicInt>>,
           lwb : Term<LogicOption<Jtype<LogicInt>>> ->
          freshTypedVars { upb: Term<Jtype<LogicInt>>,
            new_p: Term<Jtype<LogicInt>> ->
          and(cc_typ `===` CC_var(id, i, CC_subst.cc_inter(t, p), lwb),
              res `===` Type(Var(id, i, upb, lwb)),
              substitute_typ(subst, p, new_p),
              conde(freshTypedVars { ts: Term<LogicList<Jtype<LogicInt>>> ->
                    and(new_p `===` Intersect(ts),
                        upb `===` Intersect((t + ts)))
                    },
                    and(upb `===` Intersect((t + (new_p + nilLogicList()))),
                        (new_p `!==` Intersect(wildcard())))))
          } })
  
  
  context(RelationalContext)
  override fun  targs_pred(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        targ: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool>): Goal =
    conde(freshTypedVars { upb: Term<Jtype<LogicInt>>,
            lwb: Term<Jtype<LogicInt>> ->
          and((targ `===` Type(Var(_f(), _f(), upb, Some(lwb)))),
              less_minus_less(lwb, upb, res))
          },
          and(res `===` true.toLogicBool(),
              (targ `!==` Type(Var(wildcard(), wildcard(), wildcard(),
                               Some(wildcard()))))))
  
  
  context(RelationalContext)
  override fun  capture_conversion(_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        _id: Term<LogicInt>, targs: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        res: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>>): Goal =
    res `===` Some(targs)
  
  
  context(RelationalContext)
  override fun  less_equal_less(_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        type_a: Term<Jarg<Jtype<LogicInt>>>,
        type_b: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool>): Goal =
    conde(and(type_a `===` type_b,
              res `===` true.toLogicBool()),
          and(type_a `!==` type_b,
              res `===` false.toLogicBool()))
  
  
  context(RelationalContext)
  override fun  class_int_sub(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        id_a: Term<LogicInt>,
        targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        id_b: Term<LogicInt>,
        targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>>, res: Term<LogicBool>
        ): Goal =
    conde(and(id_a `===` id_b,
              fold_left2o({ acc: Term<LogicBool>, ta: Term<Jarg<Jtype<LogicInt>>>, 
                          tb: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool> -> 
                          conde(and(acc `===` false.toLogicBool(),
                                    res `===` false.toLogicBool()),
                                and(acc `===` true.toLogicBool(),
                                    less_equal_less(less_minus_less, ta, tb,
                                    res))) },
              true.toLogicBool(), targs_a, targs_b, res)),
          freshTypedVars { super_: Term<LogicOption<Jtype<LogicInt>>> ->
          and(id_a `!==` id_b,
              CT.get_superclass_by_id(id_a, id_b, super_),
              conde(freshTypedVars { targs_b2: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
                      new_targs_b2: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                    and(conde(super_ `===` Some(Class_(id_b, targs_b2)),
                              super_ `===` Some(Interface(id_b, targs_b2))),
                        mapo({ arg: Term<Jarg<Jtype<LogicInt>>>, res: Term<Jarg<Jtype<LogicInt>>> -> 
                             substitute_arg(targs_a, arg, res) },
                        targs_b2, new_targs_b2),
                        conde(and(targs_b `===` new_targs_b2,
                                  res `===` true.toLogicBool()),
                              and(res `===` false.toLogicBool(),
                                  targs_b `!==` new_targs_b2)))
                    },
                    and(super_ `===` None(),
                        res `===` false.toLogicBool())))
          })
  
  
  context(RelationalContext)
  override fun  minus_less_minus(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        type_a: Term<Jtype<LogicInt>>, type_b: Term<Jtype<LogicInt>>,
        res: Term<LogicBool>): Goal =
    conde(freshTypedVars { id_a: Term<LogicInt>,
            targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
            converted: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ->
          and(type_a `===` Class_(id_a, targs_a),
              capture_conversion(less_minus_less, id_a, targs_a, converted),
              conde(and(converted `===` None(),
                        res `===` false.toLogicBool()),
                    freshTypedVars { targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                    and(converted `===` Some(targs_a),
                        conde(freshTypedVars { id_b: Term<LogicInt>,
                                targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                              and(conde(type_b `===` Interface(id_b, targs_b),
                                        type_b `===` Class_(id_b, targs_b)),
                                  class_int_sub(less_minus_less, id_a,
                                  targs_a, id_b, targs_b, res))
                              },
                              freshTypedVars { typ: Term<Jtype<LogicInt>> ->
                              and((type_b `===` Var(_f(), _f(), _f(),
                                                Some(typ))),
                                  conde(and(typ `===` type_a,
                                            res `===` true.toLogicBool()),
                                        and(res `===` false.toLogicBool(),
                                            typ `!==` type_a)))
                              },
                              and(res `===` false.toLogicBool(),
                                  (type_b `!==` Var(wildcard(), wildcard(),
                                                wildcard(), Some(wildcard()))),
                                  (type_b `!==` Interface(wildcard(),
                                                wildcard())),
                                  (type_b `!==` Class_(wildcard(),
                                                wildcard())))))
                    }))
          },
          freshTypedVars { id_a: Term<LogicInt>,
            targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
            converted: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ->
          and(type_a `===` Interface(id_a, targs_a),
              capture_conversion(less_minus_less, id_a, targs_a, converted),
              conde(and(converted `===` None(),
                        res `===` false.toLogicBool()),
                    freshTypedVars { targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                    and(converted `===` Some(targs_a),
                        conde(freshTypedVars { id_b: Term<LogicInt>,
                                targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                              and(type_b `===` Interface(id_b, targs_b),
                                  class_int_sub(less_minus_less, id_a,
                                  targs_a, id_b, targs_b, res))
                              },
                              freshTypedVars { typ: Term<Jtype<LogicInt>> ->
                              and((type_b `===` Var(_f(), _f(), _f(),
                                                Some(typ))),
                                  conde(and(typ `===` type_a,
                                            res `===` true.toLogicBool()),
                                        and(res `===` false.toLogicBool(),
                                            typ `!==` type_a)))
                              },
                              and(res `===` false.toLogicBool(),
                                  (type_b `!==` Var(wildcard(), wildcard(),
                                                wildcard(), Some(wildcard()))),
                                  (type_b `!==` Class_(wildcard(),
                                                wildcard())),
                                  (type_b `!==` Interface(wildcard(),
                                                wildcard())))))
                    }))
          },
          freshTypedVars { ta: Term<Jtype<LogicInt>> ->
          and(type_a `===` Array_(ta),
              conde(and(ta `===` CT.object_t,
                        conde(and(res `===` true.toLogicBool(),
                                  conde(type_b `===` CT.object_t,
                                        type_b `===` CT.cloneable_t,
                                        type_b `===` CT.serializable_t)),
                              and(type_b `!==` CT.object_t,
                                  type_b `!==` CT.serializable_t,
                                  type_b `!==` CT.cloneable_t,
                                  conde(freshTypedVars { tb: Term<Jtype<LogicInt>> ->
                                        and(type_b `===` Array_(tb),
                                            minus_less_minus(less_minus_less,
                                            ta, tb, res))
                                        },
                                        and(res `===` false.toLogicBool(),
                                            (type_b `!==` Array_(wildcard()))))))),
                    and(ta `!==` CT.object_t,
                        conde(freshTypedVars { tb: Term<Jtype<LogicInt>> ->
                              and(type_b `===` Array_(tb),
                                  minus_less_minus(less_minus_less, ta, tb,
                                  res))
                              },
                              and(res `===` false.toLogicBool(),
                                  (type_b `!==` Array_(wildcard())))))))
          },
          freshTypedVars { ts: Term<LogicList<Jtype<LogicInt>>> ->
          and(type_a `===` Intersect(ts),
              memo(type_b, ts, res))
          },
          freshTypedVars { upb_typ: Term<Jtype<LogicInt>> ->
          and((type_a `===` Var(_f(), _f(), upb_typ, _f())),
              conde(and(upb_typ `===` type_b,
                        res `===` true.toLogicBool()),
                    and(res `===` false.toLogicBool(),
                        upb_typ `!==` type_b)))
          },
          and(type_a `===` Null(),
              conde(and(type_b `===` Null(),
                        res `===` false.toLogicBool()),
                    and(res `===` true.toLogicBool(),
                        type_b `!==` Null()))))
  
  }}
// Put epilogue here 
