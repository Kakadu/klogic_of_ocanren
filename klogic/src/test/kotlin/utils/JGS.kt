// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName"
  , "PropertyName", "ClassName", "LocalVariableName", "SpellCheckingInspection"
  , "PARAMETER_NAME_CHANGED_ON_OVERRIDE", "NAME_SHADOWING"
  )

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.*
import org.klogic.utils.terms.LogicBool.Companion.toLogicBool
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import utils.LogicInt
import utils.LogicInt.Companion.toLogic
import utils.Some
import utils.None
import utils.LogicOption
//import utils.None

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

context(RelationalContext)
fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }

context(RelationalContext)
fun <A: Term<A>> wc(f : (Term<A>) -> Goal ) : Goal = success

// There are 16 relations
context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapo(f: (Term<A>, Term<B>) -> Goal,
l: Term<LogicList<A>>, res: Term<LogicList<B>>): Goal =
conde(pause { and(l `===` nilLogicList(),
                  res `===` nilLogicList()) },
      freshTypedVars { l_hd: Term<A>, l_tl: Term<LogicList<A>>,
        res_hd: Term<B>, res_tl: Term<LogicList<B>> ->
      and(l `===` (l_hd + l_tl),
          res `===` (res_hd + res_tl),
          f(l_hd, res_hd),
          mapo(f, l_tl, res_tl))
      })
context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapio_helper(f: (Term<PeanoLogicNumber>, Term<A>, Term<B>) -> Goal,
i: Term<PeanoLogicNumber>, l: Term<LogicList<A>>,
res: Term<LogicList<B>>): Goal =
conde(pause { and(l `===` nilLogicList(),
                  res `===` nilLogicList()) },
      freshTypedVars { l_hd: Term<A>, l_tl: Term<LogicList<A>>,
        res_hd: Term<B>, res_tl: Term<LogicList<B>> ->
      and(l `===` (l_hd + l_tl),
          res `===` (res_hd + res_tl),
          f(i, l_hd, res_hd),
          mapio_helper(f, NextNaturalNumber(i), l_tl, res_tl))
      })
context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapio(f: (Term<PeanoLogicNumber>, Term<A>, Term<B>) -> Goal,
l: Term<LogicList<A>>, res: Term<LogicList<B>>): Goal =
mapio_helper(f, ZeroNaturalNumber, l, res)
context(RelationalContext)
fun <A : Term<A>> memo(e: Term<A>, l: Term<LogicList<A>>,
res: Term<LogicBool>): Goal =
conde(pause { and(l `===` nilLogicList(),
                  res `===` false.toLogicBool()) },
      freshTypedVars { hd: Term<A>, tl: Term<LogicList<A>> ->
      and(l `===` (hd + tl),
          conde(pause { and(hd `===` e,
                            res `===` true.toLogicBool()) },
                pause { and(hd `!==` e,
                            memo(e, tl, res)) }))
      })
context(RelationalContext)
fun <A : Term<A>> ntho(l: Term<LogicList<A>>, n: Term<PeanoLogicNumber>,
rez: Term<A>): Goal =
freshTypedVars { hd: Term<A>, tl: Term<LogicList<A>> ->
and(l `===` (hd + tl),
    conde(pause { and(n `===` ZeroNaturalNumber,
                      hd `===` rez) },
          freshTypedVars { prev: Term<PeanoLogicNumber> ->
          and(n `===` NextNaturalNumber(prev),
              ntho(tl, prev, rez))
          }))
}
context(RelationalContext)
fun <A : Term<A>> for_allo(p: (Term<A>, Term<LogicBool>) -> Goal,
l: Term<LogicList<A>>, res: Term<LogicBool>): Goal =
conde(pause { and(l `===` nilLogicList(),
                  res `===` true.toLogicBool()) },
      freshTypedVars { hd: Term<A>, tl: Term<LogicList<A>>,
        p_res: Term<LogicBool> ->
      and(l `===` (hd + tl),
          p(hd, p_res),
          conde(pause { and(p_res `===` true.toLogicBool(),
                            for_allo(p, tl, res))
                },
                pause { and(p_res `===` false.toLogicBool(),
                            res `===` false.toLogicBool())
                }))
      })
context(RelationalContext)
fun <C : Term<C>, B : Term<B>, A : Term<A>> fold_left2o(f: (Term<A>, Term<B>, Term<C>, Term<A>) -> Goal,
acc: Term<A>, l1: Term<LogicList<B>>, l2: Term<LogicList<C>>,
res: Term<A>): Goal =
conde(pause { and(l1 `===` nilLogicList(),
                  l2 `===` nilLogicList(),
                  res `===` acc)
      },
      freshTypedVars { hd1: Term<B>, tl1: Term<LogicList<B>>, hd2: Term<C>,
        tl2: Term<LogicList<C>>, new_acc: Term<A> ->
      and(l1 `===` (hd1 + tl1),
          l2 `===` (hd2 + tl2),
          f(acc, hd1, hd2, new_acc),
          fold_left2o(f, new_acc, tl1, tl2, res))
      })
context(RelationalContext)
fun <ID : Term<ID>> substitute_typ(subst: Term<LogicList<Jarg<Jtype<ID>>>>,
typ: Term<Jtype<ID>>, res: Term<Jtype<ID>>): Goal =
conde(freshTypedVars { param: Term<Jtype<ID>>, new_param: Term<Jtype<ID>> ->
      and(typ `===` Array_(param),
          res `===` Array_(new_param),
          substitute_typ(subst, param, new_param))
      },
      freshTypedVars { id: Term<ID>, args: Term<LogicList<Jarg<Jtype<ID>>>>,
        new_args: Term<LogicList<Jarg<Jtype<ID>>>> ->
      and(typ `===` Class_(id, args),
          res `===` Class_(id, new_args),
          mapo({ targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>> -> 
               substitute_arg(subst, targ, res) },
          args, new_args))
      },
      freshTypedVars { id: Term<ID>, args: Term<LogicList<Jarg<Jtype<ID>>>>,
        new_args: Term<LogicList<Jarg<Jtype<ID>>>> ->
      and(typ `===` Interface(id, args),
          res `===` Interface(id, new_args),
          mapo({ targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>> -> 
               substitute_arg(subst, targ, res) },
          args, new_args))
      },
      freshTypedVars { typs: Term<LogicList<Jtype<ID>>>,
        new_typs: Term<LogicList<Jtype<ID>>> ->
      and(typ `===` Intersect(typs),
          res `===` Intersect(new_typs),
          mapo({ typ: Term<Jtype<ID>>, res: Term<Jtype<ID>> -> substitute_typ(subst,
                                                               typ, res) },
          typs, new_typs))
      },
      pause { and(typ `===` Null(),
                  res `===` Null()) })
context(RelationalContext)
fun <ID : Term<ID>> substitute_arg(subst: Term<LogicList<Jarg<Jtype<ID>>>>,
targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>>): Goal =
conde(freshTypedVars { index: Term<PeanoLogicNumber> ->
      and(/* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c39 : Term<ID> ->
          /* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c48 : Term<Jtype<ID>> ->
          /* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c51 : Term<LogicOption<Jtype<ID>>> ->
          (targ `===` Type(Var(__JGS_JGS_ml_c39, index, __JGS_JGS_ml_c48,
                           __JGS_JGS_ml_c51))) } } },
          ntho(subst, index, res))
      },
      freshTypedVars { typ: Term<Jtype<ID>>, new_typ: Term<Jtype<ID>> ->
      and(targ `===` Type(typ),
          res `===` Type(new_typ),
          substitute_typ(subst, typ, new_typ))
      },
      pause { and(targ `===` Wildcard(None()),
                  res `===` Wildcard(None())) },
      freshTypedVars { p: Term<Polarity/*237*/>, typ: Term<Jtype<ID>>,
        new_typ: Term<Jtype<ID>> ->
      and(targ `===` Wildcard(Some(LogicPair(p, typ))),
          res `===` Wildcard(Some(LogicPair(p, new_typ))),
          substitute_typ(subst, typ, new_typ))
      })
// CLASSTABLE 
interface CLASSTABLE {
  // decl_by_id
  context(RelationalContext)
  fun decl_by_id(v1: Term<LogicInt>, v2: Term<Decl<LogicInt>> ): Goal
  // get_superclass_by_id
  context(RelationalContext)
  fun get_superclass_by_id(v3: Term<LogicInt>, v4: Term<LogicInt>,
  v5: Term<LogicOption<Jtype<LogicInt>>> ): Goal
  val object_t : Term<Jtype<LogicInt>>
  val cloneable_t : Term<Jtype<LogicInt>>
  val serializable_t : Term<Jtype<LogicInt>>
  // new_var
  context(RelationalContext)
  fun new_var( ): Term<LogicInt>
  }

// VERIFIER 
interface VERIFIER {
  // params
  context(RelationalContext)
  fun params(v1: Term<LogicInt>, v2: Term<LogicList<Jtype<LogicInt>>> ): Goal
  // raw_helper
  context(RelationalContext)
  fun raw_helper(v3: Term<LogicInt>, v4: Term<PeanoLogicNumber>,
  v5: Term<Jarg<Jtype<LogicInt>>>, v6: Term<ClosureConversionType<LogicInt>>
  ): Goal
  // subst_helper
  context(RelationalContext)
  fun subst_helper(v7: Term<ClosureConversionType<LogicInt>>,
  v8: Term<Jarg<Jtype<LogicInt>>> ): Goal
  // targs_helper
  context(RelationalContext)
  fun targs_helper(v9: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v10: Term<ClosureConversionType<LogicInt>>,
  v11: Term<Jarg<Jtype<LogicInt>>> ): Goal
  // targs_pred
  context(RelationalContext)
  fun targs_pred(
  v12: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v13: Term<Jarg<Jtype<LogicInt>>>, v14: Term<LogicBool> ): Goal
  // capture_conversion
  context(RelationalContext)
  fun capture_conversion(
  v15: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v16: Term<LogicInt>, v17: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v18: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ): Goal
  // less_equal_less
  context(RelationalContext)
  fun less_equal_less(
  v19: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v20: Term<Jarg<Jtype<LogicInt>>>, v21: Term<Jarg<Jtype<LogicInt>>>,
  v22: Term<LogicBool> ): Goal
  // class_int_sub
  context(RelationalContext)
  fun class_int_sub(
  v23: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v24: Term<LogicInt>, v25: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v26: Term<LogicInt>, v27: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v28: Term<LogicBool> ): Goal
  // minus_less_minus
  context(RelationalContext)
  fun minus_less_minus(
  v29: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v30: Term<Jtype<LogicInt>>, v31: Term<Jtype<LogicInt>>,
  v32: Term<LogicBool> ): Goal
  }

// functor
public val Verifier : (CLASSTABLE) -> VERIFIER = { CT: CLASSTABLE ->
object: VERIFIER {
  context(RelationalContext)
  override fun  params(id: Term<LogicInt>,
  p: Term<LogicList<Jtype<LogicInt>>>): Goal =
  freshTypedVars { decl: Term<Decl<LogicInt>> ->
  and(CT.decl_by_id(id, decl),
      conde(/* NOTE: fresh without delay */
            freshTypedVars { __JGS_JGS_ml_c33 : Term<Jtype<LogicInt>> ->
            /* NOTE: fresh without delay */
            freshTypedVars { __JGS_JGS_ml_c36 : Term<LogicList<Jtype<LogicInt>>> ->
            (decl `===` C(p, __JGS_JGS_ml_c33, __JGS_JGS_ml_c36)) } },
            /* NOTE: fresh without delay */
            freshTypedVars { __JGS_JGS_ml_c58 : Term<LogicList<Jtype<LogicInt>>> ->
            (decl `===` I(p, __JGS_JGS_ml_c58)) }))
  }
context(RelationalContext)
override fun  raw_helper(id: Term<LogicInt>, i: Term<PeanoLogicNumber>,
targ: Term<Jarg<Jtype<LogicInt>>>,
cc_targ: Term<ClosureConversionType<LogicInt>>): Goal =
conde(freshTypedVars { t: Term<Jtype<LogicInt>> ->
      and(targ `===` Type(t),
          cc_targ `===` CC_type(t))
      },
      freshTypedVars { param: Term<Jtype<LogicInt>>,
        params_val: Term<LogicList<Jtype<LogicInt>>> ->
      and(targ `===` Wildcard(None()),
          cc_targ `===` CC_var(CT.new_var(), i, CC_subst(param),
                        Some(Null())),
          params(id, params_val),
          ntho(params_val, i, param))
      },
      freshTypedVars { t: Term<Jtype<LogicInt>>,
        subst: Term<Jtype<LogicInt>>,
        params_val: Term<LogicList<Jtype<LogicInt>>> ->
      and(targ `===` Wildcard(Some(LogicPair(Super(), t))),
          cc_targ `===` CC_var(CT.new_var(), i, CC_subst(subst), Some(t)),
          params(id, params_val),
          ntho(params_val, i, subst))
      },
      freshTypedVars { t: Term<Jtype<LogicInt>>, t2: Term<Jtype<LogicInt>>,
        params_val: Term<LogicList<Jtype<LogicInt>>> ->
      and(targ `===` Wildcard(Some(LogicPair(Extends(), t))),
          cc_targ `===` CC_var(CT.new_var(), i, CC_subst.cc_inter(t, t2),
                        Some(Null())),
          params(id, params_val),
          ntho(params_val, i, t2))
      })
context(RelationalContext)
override fun  subst_helper(raw_element: Term<ClosureConversionType<LogicInt>>,
targ: Term<Jarg<Jtype<LogicInt>>>): Goal =
conde(freshTypedVars { t: Term<Jtype<LogicInt>> ->
      and(raw_element `===` CC_type(t),
          targ `===` Type(t))
      },
      freshTypedVars { id: Term<LogicInt>, i: Term<PeanoLogicNumber> ->
      and(/* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c39 : Term<ClosureConversion<LogicInt>> ->
          /* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c42 : Term<LogicOption<Jtype<LogicInt>>> ->
          (raw_element `===` CC_var(id, i, __JGS_JGS_ml_c39,
                             __JGS_JGS_ml_c42)) } },
          targ `===` Type(Var(id, i, Null(), None())))
      })
context(RelationalContext)
override fun  targs_helper(subst: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
cc_typ: Term<ClosureConversionType<LogicInt>>,
res: Term<Jarg<Jtype<LogicInt>>>): Goal =
conde(freshTypedVars { t: Term<Jtype<LogicInt>>,
        new_t: Term<Jtype<LogicInt>> ->
      and(cc_typ `===` CC_type(t),
          res `===` Type(new_t),
          substitute_typ(subst, t, new_t))
      },
      freshTypedVars { id: Term<LogicInt>, i: Term<PeanoLogicNumber>,
        p: Term<Jtype<LogicInt>>, new_p: Term<Jtype<LogicInt>>,
        lwb: Term<LogicOption<Jtype<LogicInt>>> ->
      and(cc_typ `===` CC_var(id, i, CC_subst(p), lwb),
          res `===` Type(Var(id, i, new_p, lwb)),
          substitute_typ(subst, p, new_p))
      },
      /* NOTE: fresh without delay */
      freshTypedVars { id : Term<LogicInt>,  i : Term<PeanoLogicNumber>,
       t : Term<Jtype<LogicInt>>,  p : Term<Jtype<LogicInt>>,
       lwb : Term<LogicOption<Jtype<LogicInt>>> ->
      freshTypedVars { upb: Term<Jtype<LogicInt>>,
        new_p: Term<Jtype<LogicInt>> ->
      and(cc_typ `===` CC_var(id, i, CC_subst.cc_inter(t, p), lwb),
          res `===` Type(Var(id, i, upb, lwb)),
          substitute_typ(subst, p, new_p),
          conde(freshTypedVars { ts: Term<LogicList<Jtype<LogicInt>>> ->
                and(new_p `===` Intersect(ts),
                    upb `===` Intersect((t + ts)))
                },
                pause { and(upb `===` Intersect((t + (new_p + nilLogicList()))),
                            wc {__JGS_JGS_ml_c38 : Term<LogicList<Jtype<LogicInt>>> ->
                            (new_p `!==` Intersect(__JGS_JGS_ml_c38))})
                }))
      } })
context(RelationalContext)
override fun  targs_pred(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
targ: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool>): Goal =
conde(freshTypedVars { upb: Term<Jtype<LogicInt>>,
        lwb: Term<Jtype<LogicInt>> ->
      and(/* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c31 : Term<LogicInt> ->
          /* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c34 : Term<PeanoLogicNumber> ->
          (targ `===` Type(Var(__JGS_JGS_ml_c31, __JGS_JGS_ml_c34, upb,
                           Some(lwb)))) } },
          less_minus_less(lwb, upb, res))
      },
      pause { and(res `===` true.toLogicBool(),
                  wc {__JGS_JGS_ml_c55 : Term<LogicInt> ->
                  wc {__JGS_JGS_ml_c58 : Term<PeanoLogicNumber> ->
                  wc {__JGS_JGS_ml_c61 : Term<Jtype<LogicInt>> ->
                  wc {__JGS_JGS_ml_c74 : Term<Jtype<LogicInt>> ->
                  (targ `!==` Type(Var(__JGS_JGS_ml_c55, __JGS_JGS_ml_c58,
                                   __JGS_JGS_ml_c61, Some(__JGS_JGS_ml_c74))))}}}})
      })
context(RelationalContext)
override fun  capture_conversion(_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
_id: Term<LogicInt>, targs: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
res: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>>): Goal =
res `===` Some(targs)
context(RelationalContext)
override fun  less_equal_less(_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
type_a: Term<Jarg<Jtype<LogicInt>>>, type_b: Term<Jarg<Jtype<LogicInt>>>,
res: Term<LogicBool>): Goal =
conde(pause { and(type_a `===` type_b,
                  res `===` true.toLogicBool()) },
      pause { and(type_a `!==` type_b,
                  res `===` false.toLogicBool()) })
context(RelationalContext)
override fun  class_int_sub(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
id_a: Term<LogicInt>, targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
id_b: Term<LogicInt>, targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
res: Term<LogicBool>): Goal =
conde(pause { and(id_a `===` id_b,
                  fold_left2o({ acc: Term<LogicBool>, ta: Term<Jarg<Jtype<LogicInt>>>, 
                              tb: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool> -> 
                              conde(pause { and(acc `===` false.toLogicBool(),
                                                res `===` false.toLogicBool())
                                    },
                                    pause { and(acc `===` true.toLogicBool(),
                                                less_equal_less(less_minus_less,
                                                ta, tb, res))
                                    }) },
                  true.toLogicBool(), targs_a, targs_b, res))
      },
      freshTypedVars { super_: Term<LogicOption<Jtype<LogicInt>>> ->
      and(id_a `!==` id_b,
          CT.get_superclass_by_id(id_a, id_b, super_),
          conde(freshTypedVars { targs_b2: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
                  new_targs_b2: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                and(conde(/* NOTE: fresh without delay */
                          freshTypedVars { __JGS_JGS_ml_c50 : Term<LogicInt> ->
                          (super_ `===` Some(Class_(__JGS_JGS_ml_c50,
                                             targs_b2))) },
                          /* NOTE: fresh without delay */
                          freshTypedVars { __JGS_JGS_ml_c53 : Term<LogicInt> ->
                          (super_ `===` Some(Interface(__JGS_JGS_ml_c53,
                                             targs_b2))) }),
                    mapo({ arg: Term<Jarg<Jtype<LogicInt>>>, res: Term<Jarg<Jtype<LogicInt>>> -> 
                         substitute_arg(targs_a, arg, res) },
                    targs_b2, new_targs_b2),
                    conde(pause { and(targs_b `===` new_targs_b2,
                                      res `===` true.toLogicBool())
                          },
                          pause { and(res `===` false.toLogicBool(),
                                      targs_b `!==` new_targs_b2)
                          }))
                },
                pause { and(super_ `===` None(),
                            res `===` false.toLogicBool())
                }))
      })
context(RelationalContext)
override fun  minus_less_minus(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
type_a: Term<Jtype<LogicInt>>, type_b: Term<Jtype<LogicInt>>,
res: Term<LogicBool>): Goal =
conde(freshTypedVars { id_a: Term<LogicInt>,
        targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        converted: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ->
      and(type_a `===` Class_(id_a, targs_a),
          capture_conversion(less_minus_less, id_a, targs_a, converted),
          conde(pause { and(converted `===` None(),
                            res `===` false.toLogicBool())
                },
                freshTypedVars { targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                and(converted `===` Some(targs_a),
                    conde(freshTypedVars { id_b: Term<LogicInt>,
                            targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                          and(conde(type_b `===` Interface(id_b, targs_b),
                                    type_b `===` Class_(id_b, targs_b)),
                              class_int_sub(less_minus_less, id_a, targs_a,
                              id_b, targs_b, res))
                          },
                          freshTypedVars { typ: Term<Jtype<LogicInt>> ->
                          and(/* NOTE: fresh without delay */
                              freshTypedVars { __JGS_JGS_ml_c40 : Term<LogicInt> ->
                              /* NOTE: fresh without delay */
                              freshTypedVars { __JGS_JGS_ml_c43 : Term<PeanoLogicNumber> ->
                              /* NOTE: fresh without delay */
                              freshTypedVars { __JGS_JGS_ml_c46 : Term<Jtype<LogicInt>> ->
                              (type_b `===` Var(__JGS_JGS_ml_c40,
                                            __JGS_JGS_ml_c43,
                                            __JGS_JGS_ml_c46, Some(typ))) 
                              } } },
                              conde(pause { and(typ `===` type_a,
                                                res `===` true.toLogicBool())
                                    },
                                    pause { and(res `===` false.toLogicBool(),
                                                typ `!==` type_a)
                                    }))
                          },
                          pause { and(res `===` false.toLogicBool(),
                                      wc {__JGS_JGS_ml_c40 : Term<LogicInt> ->
                                      wc {__JGS_JGS_ml_c43 : Term<PeanoLogicNumber> ->
                                      wc {__JGS_JGS_ml_c46 : Term<Jtype<LogicInt>> ->
                                      wc {__JGS_JGS_ml_c59 : Term<Jtype<LogicInt>> ->
                                      (type_b `!==` Var(__JGS_JGS_ml_c40,
                                                    __JGS_JGS_ml_c43,
                                                    __JGS_JGS_ml_c46,
                                                    Some(__JGS_JGS_ml_c59)))}}}},
                                      wc {__JGS_JGS_ml_c46 : Term<LogicInt> ->
                                      wc {__JGS_JGS_ml_c49 : Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                                      (type_b `!==` Interface(__JGS_JGS_ml_c46,
                                                    __JGS_JGS_ml_c49))}},
                                      wc {__JGS_JGS_ml_c43 : Term<LogicInt> ->
                                      wc {__JGS_JGS_ml_c46 : Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                                      (type_b `!==` Class_(__JGS_JGS_ml_c43,
                                                    __JGS_JGS_ml_c46))}})
                          }))
                }))
      },
      freshTypedVars { id_a: Term<LogicInt>,
        targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        converted: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ->
      and(type_a `===` Interface(id_a, targs_a),
          capture_conversion(less_minus_less, id_a, targs_a, converted),
          conde(pause { and(converted `===` None(),
                            res `===` false.toLogicBool())
                },
                freshTypedVars { targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                and(converted `===` Some(targs_a),
                    conde(freshTypedVars { id_b: Term<LogicInt>,
                            targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                          and(conde(type_b `===` Class_(id_b, targs_b),
                                    type_b `===` Interface(id_b, targs_b)),
                              class_int_sub(less_minus_less, id_a, targs_a,
                              id_b, targs_b, res))
                          },
                          freshTypedVars { typ: Term<Jtype<LogicInt>> ->
                          and(/* NOTE: fresh without delay */
                              freshTypedVars { __JGS_JGS_ml_c40 : Term<LogicInt> ->
                              /* NOTE: fresh without delay */
                              freshTypedVars { __JGS_JGS_ml_c43 : Term<PeanoLogicNumber> ->
                              /* NOTE: fresh without delay */
                              freshTypedVars { __JGS_JGS_ml_c46 : Term<Jtype<LogicInt>> ->
                              (type_b `===` Var(__JGS_JGS_ml_c40,
                                            __JGS_JGS_ml_c43,
                                            __JGS_JGS_ml_c46, Some(typ))) 
                              } } },
                              conde(pause { and(typ `===` type_a,
                                                res `===` true.toLogicBool())
                                    },
                                    pause { and(res `===` false.toLogicBool(),
                                                typ `!==` type_a)
                                    }))
                          },
                          pause { and(res `===` false.toLogicBool(),
                                      wc {__JGS_JGS_ml_c40 : Term<LogicInt> ->
                                      wc {__JGS_JGS_ml_c43 : Term<PeanoLogicNumber> ->
                                      wc {__JGS_JGS_ml_c46 : Term<Jtype<LogicInt>> ->
                                      wc {__JGS_JGS_ml_c59 : Term<Jtype<LogicInt>> ->
                                      (type_b `!==` Var(__JGS_JGS_ml_c40,
                                                    __JGS_JGS_ml_c43,
                                                    __JGS_JGS_ml_c46,
                                                    Some(__JGS_JGS_ml_c59)))}}}},
                                      wc {__JGS_JGS_ml_c43 : Term<LogicInt> ->
                                      wc {__JGS_JGS_ml_c46 : Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                                      (type_b `!==` Class_(__JGS_JGS_ml_c43,
                                                    __JGS_JGS_ml_c46))}},
                                      wc {__JGS_JGS_ml_c46 : Term<LogicInt> ->
                                      wc {__JGS_JGS_ml_c49 : Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                                      (type_b `!==` Interface(__JGS_JGS_ml_c46,
                                                    __JGS_JGS_ml_c49))}})
                          }))
                }))
      },
      freshTypedVars { ta: Term<Jtype<LogicInt>> ->
      and(type_a `===` Array_(ta),
          conde(pause { and(ta `===` CT.object_t,
                            conde(pause { and(res `===` true.toLogicBool(),
                                              conde(type_b `===` CT.object_t,
                                                    type_b `===` CT.cloneable_t,
                                                    type_b `===` CT.serializable_t))
                                  },
                                  pause { and(type_b `!==` CT.object_t,
                                              type_b `!==` CT.serializable_t,
                                              type_b `!==` CT.cloneable_t,
                                              conde(freshTypedVars { 
                                                      tb: Term<Jtype<LogicInt>> ->
                                                    and(type_b `===` 
                                                        Array_(tb),
                                                        minus_less_minus(less_minus_less,
                                                        ta, tb, res))
                                                    },
                                                    pause { and(res `===` false.toLogicBool(),
                                                                wc {__JGS_JGS_ml_c74 : Term<Jtype<LogicInt>> ->
                                                                (type_b `!==` 
                                                                Array_(__JGS_JGS_ml_c74))})
                                                    }))
                                  }))
                },
                pause { and(ta `!==` CT.object_t,
                            conde(freshTypedVars { tb: Term<Jtype<LogicInt>> ->
                                  and(type_b `===` Array_(tb),
                                      minus_less_minus(less_minus_less, ta,
                                      tb, res))
                                  },
                                  pause { and(res `===` false.toLogicBool(),
                                              wc {__JGS_JGS_ml_c67 : Term<Jtype<LogicInt>> ->
                                              (type_b `!==` Array_(__JGS_JGS_ml_c67))})
                                  }))
                }))
      },
      freshTypedVars { ts: Term<LogicList<Jtype<LogicInt>>> ->
      and(type_a `===` Intersect(ts),
          memo(type_b, ts, res))
      },
      freshTypedVars { upb_typ: Term<Jtype<LogicInt>> ->
      and(/* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c26 : Term<LogicInt> ->
          /* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c29 : Term<PeanoLogicNumber> ->
          /* NOTE: fresh without delay */
          freshTypedVars { __JGS_JGS_ml_c40 : Term<LogicOption<Jtype<LogicInt>>> ->
          (type_a `===` Var(__JGS_JGS_ml_c26, __JGS_JGS_ml_c29, upb_typ,
                        __JGS_JGS_ml_c40)) } } },
          conde(pause { and(upb_typ `===` type_b,
                            res `===` true.toLogicBool())
                },
                pause { and(res `===` false.toLogicBool(),
                            upb_typ `!==` type_b)
                }))
      },
      pause { and(type_a `===` Null(),
                  conde(pause { and(type_b `===` Null(),
                                    res `===` false.toLogicBool())
                        },
                        pause { and(res `===` true.toLogicBool(),
                                    type_b `!==` Null())
                        }))
      })
}}
context(RelationalContext)
fun  only_classes_interfaces_and_arrays(q: Term<Jtype<LogicInt>>): Goal =
wc {inter : Term<LogicList<Jtype<LogicInt>>> ->
wc {id : Term<LogicInt> ->
wc {lwb : Term<PeanoLogicNumber> ->
wc {upb : Term<Jtype<LogicInt>> ->
wc {index : Term<LogicOption<Jtype<LogicInt>>> ->
pause { and(q `!==` Null(),
            q `!==` Intersect(inter),
            q `!==` Var(id, lwb, upb, index))
}}}}}}
context(RelationalContext)
fun <B : Term<B>, A : Term<A>> list_same_length(xs: Term<LogicList<A>>,
ys: Term<LogicList<B>>): Goal =
conde(freshTypedVars { h1: Term<A>, h2: Term<B>, tl1: Term<LogicList<A>>,
        tl2: Term<LogicList<B>> ->
      and(xs `===` (h1 + tl1),
          ys `===` (h2 + tl2),
          list_same_length(tl1, tl2))
      },
      pause { and(xs `===` nilLogicList(),
                  ys `===` nilLogicList()) })
// CLOSURE 
interface CLOSURE {
  // direct_subtyping
  context(RelationalContext)
  fun direct_subtyping(v1: (Term<Jtype<LogicInt>>, Goal, Goal) -> Goal,
  v2: ((Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal, Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v3: Goal, v4: Term<Jtype<LogicInt>>, v5: Term<Jtype<LogicInt>> ): Goal
  // closure
  context(RelationalContext)
  fun closure(v6: (Term<Jtype<LogicInt>>, Goal, Goal) -> Goal,
  v7: ((Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal, Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v8: Goal, v9: Term<Jtype<LogicInt>>, v10: Term<Jtype<LogicInt>> ): Goal
  }

// functor
public val Closure : (CLASSTABLE) -> CLOSURE = { CT: CLASSTABLE ->
object: CLOSURE {
  context(RelationalContext)
  override fun  is_correct_type(closure_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>) -> Goal,
  t: Term<Jtype<LogicInt>>): Goal =
  conde(freshTypedVars { elems: Term<Jtype<LogicInt>> ->
        (t `===` Array_(elems)) },
        freshTypedVars { id: Term<LogicInt>,
          actual_params: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
          expected_params: Term<LogicList<Jtype<LogicInt>>>,
          super: Term<Jtype<LogicInt>>,
          supers: Term<LogicList<Jtype<LogicInt>>> ->
        and(t `===` Class_(id, actual_params),
            CT.decl_by_id(id, C(expected_params, super, supers)),
            list_same_length(expected_params, actual_params))
        },
        freshTypedVars { id: Term<LogicInt>,
          actual_params: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
          expected_params: Term<LogicList<Jtype<LogicInt>>>,
          supers: Term<LogicList<Jtype<LogicInt>>> ->
        and(t `===` Interface(id, actual_params),
            CT.decl_by_id(id, I(expected_params, supers)),
            list_same_length(expected_params, actual_params))
        },
        freshTypedVars { id: Term<LogicInt>, index: Term<PeanoLogicNumber>,
          upb: Term<Jtype<LogicInt>>, lwb: Term<Jtype<LogicInt>> ->
        and(t `===` Var(id, index, upb, OCanren.Std.Option.some(lwb)),
            upb `!==` lwb,
            closure_subtyping(lwb, upb))
        },
        freshTypedVars { id: Term<LogicInt>, index: Term<PeanoLogicNumber>,
          upb: Term<Jtype<LogicInt>> ->
        (t `===` Var(id, index, upb, OCanren.Std.Option.none())) },
        t `===` Null(),
        freshTypedVars { args: Term<LogicList<Jtype<LogicInt>>> ->
        (t `===` Intersect(args)) })
context(RelationalContext)
override fun  minus_less_minus(open_direct_subtyping: ((Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal, Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
closure_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>) -> Goal,
is_correct_type: (Term<Jtype<LogicInt>>) -> Goal, ta: Term<Jtype<LogicInt>>,
tb: Term<Jtype<LogicInt>>): Goal =
pause { and(open_direct_subtyping({ a: Term<Jtype<LogicInt>>, b: Term<Jtype<LogicInt>>, 
                                  rez: Term<LogicBool> -> pause { and(rez `===` true.toLogicBool(),
                                                                    closure_subtyping(a,
                                                                    b))
                                                          } },
            ta, tb, true.toLogicBool()),
            is_correct_type(ta),
            is_correct_type(tb))
}
context(RelationalContext)
override fun  less_minus_less(direct_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>) -> Goal,
query_constr: Goal, ta: Term<Jtype<LogicInt>>,
tb: Term<Jtype<LogicInt>>): Goal =
pause { and(query_constr,
            only_classes_interfaces_and_arrays(ta),
            only_classes_interfaces_and_arrays(tb),
            conde(direct_subtyping(ta, tb),
                  freshTypedVars { ti: Term<Jtype<LogicInt>> ->
                  and(tb `!==` ti,
                      ta `!==` ti,
                      ta `!==` tb,
                      only_classes_interfaces_and_arrays(ti),
                      direct_subtyping(ti, tb),
                      less_minus_less(direct_subtyping, query_constr, ta, ti))
                  }))
}
context(RelationalContext)
override fun  greater_minus_greater(direct_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>) -> Goal,
query_constr: Goal, ta: Term<Jtype<LogicInt>>,
tb: Term<Jtype<LogicInt>>): Goal =
pause { and(query_constr,
            only_classes_interfaces_and_arrays(ta),
            only_classes_interfaces_and_arrays(tb),
            conde(direct_subtyping(ta, tb),
                  freshTypedVars { ti: Term<Jtype<LogicInt>> ->
                  and(tb `!==` ti,
                      ta `!==` ti,
                      ta `!==` tb,
                      only_classes_interfaces_and_arrays(ti),
                      direct_subtyping(ta, ti),
                      greater_minus_greater(direct_subtyping, query_constr,
                      ti, tb))
                  }))
}
context(RelationalContext)
override fun  less_minus_greater(debug_var_handler: (Term<Jtype<LogicInt>>, Goal, Goal) -> Goal,
direct_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>) -> Goal,
query_constr: Goal, ta: Term<Jtype<LogicInt>>,
tb: Term<Jtype<LogicInt>>): Goal =
debug_var_handler(ta,
less_minus_less(direct_subtyping, query_constr, ta, tb),
greater_minus_greater(direct_subtyping, query_constr, ta, tb))
context(RelationalContext)
override fun  direct_subtyping(debug_var_handler: (Term<Jtype<LogicInt>>, Goal, Goal) -> Goal,
open_direct_subtyping: ((Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal, Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
query_constr: Goal, ta: Term<Jtype<LogicInt>>,
tb: Term<Jtype<LogicInt>>): Goal =
minus_less_minus(open_direct_subtyping,
{ ta: Term<Jtype<LogicInt>>, tb: Term<Jtype<LogicInt>> -> closure(debug_var_handler,
                                                          open_direct_subtyping,
                                                          query_constr, ta,
                                                          tb) },
is_correct_type({ ta: Term<Jtype<LogicInt>>, tb: Term<Jtype<LogicInt>> -> 
                closure(debug_var_handler, open_direct_subtyping,
                query_constr, ta, tb) }),
ta, tb)
context(RelationalContext)
override fun  closure(debug_var_handler: (Term<Jtype<LogicInt>>, Goal, Goal) -> Goal,
open_direct_subtyping: ((Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal, Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
query_constr: Goal, ta: Term<Jtype<LogicInt>>,
tb: Term<Jtype<LogicInt>>): Goal =
less_minus_greater(debug_var_handler,
{ ta: Term<Jtype<LogicInt>>, tb: Term<Jtype<LogicInt>> -> direct_subtyping(debug_var_handler,
                                                          open_direct_subtyping,
                                                          query_constr, ta,
                                                          tb) },
query_constr, ta, tb)
// Put epilogue here 
}}
