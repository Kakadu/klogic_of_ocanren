// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName"
  , "PropertyName", "ClassName", "LocalVariableName", "SpellCheckingInspection"
  , "PARAMETER_NAME_CHANGED_ON_OVERRIDE", "NAME_SHADOWING"
  )

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.*
import org.klogic.utils.terms.LogicBool.Companion.toLogicBool
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import utils.LogicInt
import utils.LogicInt.Companion.toLogic
import utils.Some
import utils.None
import utils.LogicOption

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

context(RelationalContext)
fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }

context(RelationalContext)
fun <A: Term<A>> wc(f : (Term<A>) -> Goal ) : Goal = f(wildcard())

// short alias for fresh type variables uses only one (i.e. wildcards in unifications)
context(RelationalContext)
fun <A: Term<A>> _f(): Term<A> = freshTypedVar()

// There are 12 relations
context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapo(f: (Term<A>, Term<B>) -> Goal,
      l: Term<LogicList<A>>, res: Term<LogicList<B>>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` nilLogicList()),
        freshTypedVars { l_hd: Term<A> l_tl: Term<LogicList<A>> res_hd: Term<B> 
          res_tl: Term<LogicList<B>> ->
        and(l `===` (l_hd + l_tl),
            res `===` (res_hd + res_tl),
            f(l_hd res_hd),
            mapo(f l_tl res_tl))
        })

context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapio_helper(f: (Term<PeanoLogicNumber>, Term<A>, Term<B>) -> Goal,
      i: Term<PeanoLogicNumber>, l: Term<LogicList<A>>,
      res: Term<LogicList<B>>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` nilLogicList()),
        freshTypedVars { l_hd: Term<A> l_tl: Term<LogicList<A>> res_hd: Term<B> 
          res_tl: Term<LogicList<B>> ->
        and(l `===` (l_hd + l_tl),
            res `===` (res_hd + res_tl),
            f(i l_hd res_hd),
            mapio_helper(f NextNaturalNumber(i) l_tl res_tl))
        })

context(RelationalContext)
fun <B : Term<B>, A : Term<A>> mapio(f: (Term<PeanoLogicNumber>, Term<A>, Term<B>) -> Goal,
      l: Term<LogicList<A>>, res: Term<LogicList<B>>): Goal =
  mapio_helper(f ZeroNaturalNumber l res)

context(RelationalContext)
fun <A : Term<A>> memo(e: Term<A>, l: Term<LogicList<A>>,
      res: Term<LogicBool>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` false.toLogicBool()),
        freshTypedVars { hd: Term<A> tl: Term<LogicList<A>> ->
        and(l `===` (hd + tl),
            conde(and(hd `===` e,
                      res `===` true.toLogicBool()),
                  and(hd `!==` e,
                      memo(e tl res))))
        })

context(RelationalContext)
fun <A : Term<A>> ntho(l: Term<LogicList<A>>, n: Term<PeanoLogicNumber>,
      rez: Term<A>): Goal =
  freshTypedVars { hd: Term<A> tl: Term<LogicList<A>> ->
  and(l `===` (hd + tl),
      conde(and(n `===` ZeroNaturalNumber,
                hd `===` rez),
            freshTypedVars { prev: Term<PeanoLogicNumber> ->
            and(n `===` NextNaturalNumber(prev),
                ntho(tl prev rez))
            }))
  }

context(RelationalContext)
fun <A : Term<A>> for_allo(p: (Term<A>, Term<LogicBool>) -> Goal,
      l: Term<LogicList<A>>, res: Term<LogicBool>): Goal =
  conde(and(l `===` nilLogicList(),
            res `===` true.toLogicBool()),
        freshTypedVars { hd: Term<A> tl: Term<LogicList<A>> p_res: Term<LogicBool> ->
        and(l `===` (hd + tl),
            p(hd p_res),
            conde(and(p_res `===` true.toLogicBool(),
                      for_allo(p tl res)),
                  and(p_res `===` false.toLogicBool(),
                      res `===` false.toLogicBool())))
        })

context(RelationalContext)
fun <C : Term<C>, B : Term<B>, A : Term<A>> fold_left2o(f: (Term<A>, Term<B>, Term<C>, Term<A>) -> Goal,
      acc: Term<A>, l1: Term<LogicList<B>>, l2: Term<LogicList<C>>,
      res: Term<A>): Goal =
  conde(and(l1 `===` nilLogicList(),
            l2 `===` nilLogicList(),
            res `===` acc),
        freshTypedVars { hd1: Term<B> tl1: Term<LogicList<B>> hd2: Term<C> 
          tl2: Term<LogicList<C>> new_acc: Term<A> ->
        and(l1 `===` (hd1 + tl1),
            l2 `===` (hd2 + tl2),
            f(acc hd1 hd2 new_acc),
            fold_left2o(f new_acc tl1 tl2 res))
        })

context(RelationalContext)
fun <ID : Term<ID>> substitute_typ(subst: Term<LogicList<Jarg<Jtype<ID>>>>,
      typ: Term<Jtype<ID>>, res: Term<Jtype<ID>>): Goal =
  conde(freshTypedVars { param: Term<Jtype<ID>> new_param: Term<Jtype<ID>> ->
        and(typ `===` Array_(param),
            res `===` Array_(new_param),
            substitute_typ(subst param new_param))
        },
        freshTypedVars { id: Term<ID> args: Term<LogicList<Jarg<Jtype<ID>>>> 
          new_args: Term<LogicList<Jarg<Jtype<ID>>>> ->
        and(typ `===` Class_(id args),
            res `===` Class_(id new_args),
            mapo({ targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>> -> 
                 substitute_arg(subst targ res) } args new_args))
        },
        freshTypedVars { id: Term<ID> args: Term<LogicList<Jarg<Jtype<ID>>>> 
          new_args: Term<LogicList<Jarg<Jtype<ID>>>> ->
        and(typ `===` Interface(id args),
            res `===` Interface(id new_args),
            mapo({ targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>> -> 
                 substitute_arg(subst targ res) } args new_args))
        },
        freshTypedVars { typs: Term<LogicList<Jtype<ID>>> new_typs: Term<LogicList<Jtype<ID>>> ->
        and(typ `===` Intersect(typs),
            res `===` Intersect(new_typs),
            mapo({ typ: Term<Jtype<ID>>, res: Term<Jtype<ID>> -> substitute_typ(subst typ res) } typs new_typs))
        },
        and(typ `===` Null(),
            res `===` Null()))

context(RelationalContext)
fun <ID : Term<ID>> substitute_arg(subst: Term<LogicList<Jarg<Jtype<ID>>>>,
      targ: Term<Jarg<Jtype<ID>>>, res: Term<Jarg<Jtype<ID>>>): Goal =
  conde(freshTypedVars { index: Term<PeanoLogicNumber> ->
        and((targ `===` Type(Var(_f() index _f() _f()))),
            ntho(subst index res))
        },
        freshTypedVars { typ: Term<Jtype<ID>> new_typ: Term<Jtype<ID>> ->
        and(targ `===` Type(typ),
            res `===` Type(new_typ),
            substitute_typ(subst typ new_typ))
        },
        and(targ `===` Wildcard(None()),
            res `===` Wildcard(None())),
        freshTypedVars { p: Term<Polarity/*94*/> typ: Term<Jtype<ID>> 
          new_typ: Term<Jtype<ID>> ->
        and(targ `===` Wildcard(Some(LogicPair(p typ))),
            res `===` Wildcard(Some(LogicPair(p new_typ))),
            substitute_typ(subst typ new_typ))
        })

// CLASSTABLE 
interface CLASSTABLE {
  
  context(RelationalContext)
  fun decl_by_id(v1: Term<LogicInt>, v2: Term<Decl<LogicInt>> ): Goal
  
  context(RelationalContext)
  fun get_superclass_by_id(v3: Term<LogicInt>, v4: Term<LogicInt>,
  v5: Term<LogicOption<Jtype<LogicInt>>> ): Goal
  
  val object_t : Term<Jtype<LogicInt>>
  
  val cloneable_t : Term<Jtype<LogicInt>>
  
  val serializable_t : Term<Jtype<LogicInt>>
  
  context(RelationalContext)
  fun new_var( ): Term<LogicInt>
  }

// VERIFIER 
interface VERIFIER {
  
  context(RelationalContext)
  fun params(v1: Term<LogicInt>, v2: Term<LogicList<Jtype<LogicInt>>> ): Goal
  
  context(RelationalContext)
  fun raw_helper(v3: Term<LogicInt>, v4: Term<PeanoLogicNumber>,
  v5: Term<Jarg<Jtype<LogicInt>>>, v6: Term<ClosureConversionType<LogicInt>>
  ): Goal
  
  context(RelationalContext)
  fun subst_helper(v7: Term<ClosureConversionType<LogicInt>>,
  v8: Term<Jarg<Jtype<LogicInt>>> ): Goal
  
  context(RelationalContext)
  fun targs_helper(v9: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v10: Term<ClosureConversionType<LogicInt>>,
  v11: Term<Jarg<Jtype<LogicInt>>> ): Goal
  
  context(RelationalContext)
  fun targs_pred(
  v12: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v13: Term<Jarg<Jtype<LogicInt>>>, v14: Term<LogicBool> ): Goal
  
  context(RelationalContext)
  fun capture_conversion(
  v15: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v16: Term<LogicInt>, v17: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v18: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ): Goal
  
  context(RelationalContext)
  fun less_equal_less(
  v19: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v20: Term<Jarg<Jtype<LogicInt>>>, v21: Term<Jarg<Jtype<LogicInt>>>,
  v22: Term<LogicBool> ): Goal
  
  context(RelationalContext)
  fun class_int_sub(
  v23: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v24: Term<LogicInt>, v25: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v26: Term<LogicInt>, v27: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
  v28: Term<LogicBool> ): Goal
  
  context(RelationalContext)
  fun minus_less_minus(
  v29: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
  v30: Term<Jtype<LogicInt>>, v31: Term<Jtype<LogicInt>>,
  v32: Term<LogicBool> ): Goal
  }

// functor
val Verifier : (CLASSTABLE) -> VERIFIER = { CT: CLASSTABLE ->
object: VERIFIER {
  context(RelationalContext)
  override fun  params(id: Term<LogicInt>,
        p: Term<LogicList<Jtype<LogicInt>>>): Goal =
    freshTypedVars { decl: Term<Decl<LogicInt>> ->
    and(CT.decl_by_id(id decl),
        conde((decl `===` C(p _f() _f())),
              (decl `===` I(p _f()))))
    }
  
  
  context(RelationalContext)
  override fun  raw_helper(id: Term<LogicInt>, i: Term<PeanoLogicNumber>,
        targ: Term<Jarg<Jtype<LogicInt>>>,
        cc_targ: Term<ClosureConversionType<LogicInt>>): Goal =
    conde(freshTypedVars { t: Term<Jtype<LogicInt>> ->
          and(targ `===` Type(t),
              cc_targ `===` CC_type(t))
          },
          freshTypedVars { param: Term<Jtype<LogicInt>> params_val: Term<LogicList<Jtype<LogicInt>>> ->
          and(targ `===` Wildcard(None()),
              cc_targ `===` CC_var(CT.new_var() i CC_subst(param) Some(
                                                                  Null())),
              params(id params_val),
              ntho(params_val i param))
          },
          freshTypedVars { t: Term<Jtype<LogicInt>> subst: Term<Jtype<LogicInt>> 
            params_val: Term<LogicList<Jtype<LogicInt>>> ->
          and(targ `===` Wildcard(Some(LogicPair(Super() t))),
              cc_targ `===` CC_var(CT.new_var() i CC_subst(subst) Some(t)),
              params(id params_val),
              ntho(params_val i subst))
          },
          freshTypedVars { t: Term<Jtype<LogicInt>> t2: Term<Jtype<LogicInt>> 
            params_val: Term<LogicList<Jtype<LogicInt>>> ->
          and(targ `===` Wildcard(Some(LogicPair(Extends() t))),
              cc_targ `===` CC_var(CT.new_var() i CC_subst.cc_inter(t t2) 
                            Some(Null())),
              params(id params_val),
              ntho(params_val i t2))
          })
  
  
  context(RelationalContext)
  override fun  subst_helper(raw_element: Term<ClosureConversionType<LogicInt>>,
        targ: Term<Jarg<Jtype<LogicInt>>>): Goal =
    conde(freshTypedVars { t: Term<Jtype<LogicInt>> ->
          and(raw_element `===` CC_type(t),
              targ `===` Type(t))
          },
          freshTypedVars { id: Term<LogicInt> i: Term<PeanoLogicNumber> ->
          and((raw_element `===` CC_var(id i _f() _f())),
              targ `===` Type(Var(id i Null() None())))
          })
  
  
  context(RelationalContext)
  override fun  targs_helper(subst: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        cc_typ: Term<ClosureConversionType<LogicInt>>,
        res: Term<Jarg<Jtype<LogicInt>>>): Goal =
    conde(freshTypedVars { t: Term<Jtype<LogicInt>> new_t: Term<Jtype<LogicInt>> ->
          and(cc_typ `===` CC_type(t),
              res `===` Type(new_t),
              substitute_typ(subst t new_t))
          },
          freshTypedVars { id: Term<LogicInt> i: Term<PeanoLogicNumber> 
            p: Term<Jtype<LogicInt>> new_p: Term<Jtype<LogicInt>> lwb: Term<LogicOption<Jtype<LogicInt>>> ->
          and(cc_typ `===` CC_var(id i CC_subst(p) lwb),
              res `===` Type(Var(id i new_p lwb)),
              substitute_typ(subst p new_p))
          },
          fresh { id : Term<LogicInt>  i : Term<PeanoLogicNumber>  t : Term<Jtype<LogicInt>> 
           p : Term<Jtype<LogicInt>>  lwb : Term<LogicOption<Jtype<LogicInt>>> ->
          freshTypedVars { upb: Term<Jtype<LogicInt>> new_p: Term<Jtype<LogicInt>> ->
          and(cc_typ `===` CC_var(id i CC_subst.cc_inter(t p) lwb),
              res `===` Type(Var(id i upb lwb)),
              substitute_typ(subst p new_p),
              conde(freshTypedVars { ts: Term<LogicList<Jtype<LogicInt>>> ->
                    and(new_p `===` Intersect(ts),
                        upb `===` Intersect((t + ts)))
                    },
                    and(upb `===` Intersect((t + (new_p + nilLogicList()))),
                        (new_p `!==` Intersect(wildcard())))))
          } })
  
  
  context(RelationalContext)
  override fun  targs_pred(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        targ: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool>): Goal =
    conde(freshTypedVars { upb: Term<Jtype<LogicInt>> lwb: Term<Jtype<LogicInt>> ->
          and((targ `===` Type(Var(_f() _f() upb Some(lwb)))),
              less_minus_less(lwb upb res))
          },
          and(res `===` true.toLogicBool(),
              (targ `!==` Type(Var(wildcard() wildcard() wildcard() Some(wildcard()))))))
  
  
  context(RelationalContext)
  override fun  capture_conversion(_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        _id: Term<LogicInt>, targs: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        res: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>>): Goal =
    res `===` Some(targs)
  
  
  context(RelationalContext)
  override fun  less_equal_less(_subtyping: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        type_a: Term<Jarg<Jtype<LogicInt>>>,
        type_b: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool>): Goal =
    conde(and(type_a `===` type_b,
              res `===` true.toLogicBool()),
          and(type_a `!==` type_b,
              res `===` false.toLogicBool()))
  
  
  context(RelationalContext)
  override fun  class_int_sub(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        id_a: Term<LogicInt>,
        targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>>,
        id_b: Term<LogicInt>,
        targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>>, res: Term<LogicBool>
        ): Goal =
    conde(and(id_a `===` id_b,
              fold_left2o({ acc: Term<LogicBool>, ta: Term<Jarg<Jtype<LogicInt>>>, 
                          tb: Term<Jarg<Jtype<LogicInt>>>, res: Term<LogicBool> -> 
                          conde(and(acc `===` false.toLogicBool(),
                                    res `===` false.toLogicBool()),
                                and(acc `===` true.toLogicBool(),
                                    less_equal_less(less_minus_less ta tb res))) } true.toLogicBool() targs_a targs_b res)),
          freshTypedVars { super_: Term<LogicOption<Jtype<LogicInt>>> ->
          and(id_a `!==` id_b,
              CT.get_superclass_by_id(id_a id_b super_),
              conde(freshTypedVars { targs_b2: Term<LogicList<Jarg<Jtype<LogicInt>>>> 
                      new_targs_b2: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                    and(conde(super_ `===` Some(Class_(id_b targs_b2)),
                              super_ `===` Some(Interface(id_b targs_b2))),
                        mapo({ arg: Term<Jarg<Jtype<LogicInt>>>, res: Term<Jarg<Jtype<LogicInt>>> -> 
                             substitute_arg(targs_a arg res) } targs_b2 new_targs_b2),
                        conde(and(targs_b `===` new_targs_b2,
                                  res `===` true.toLogicBool()),
                              and(res `===` false.toLogicBool(),
                                  targs_b `!==` new_targs_b2)))
                    },
                    and(super_ `===` None(),
                        res `===` false.toLogicBool())))
          })
  
  
  context(RelationalContext)
  override fun  minus_less_minus(less_minus_less: (Term<Jtype<LogicInt>>, Term<Jtype<LogicInt>>, Term<LogicBool>) -> Goal,
        type_a: Term<Jtype<LogicInt>>, type_b: Term<Jtype<LogicInt>>,
        res: Term<LogicBool>): Goal =
    conde(freshTypedVars { id_a: Term<LogicInt> targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> 
            converted: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ->
          and(type_a `===` Class_(id_a targs_a),
              capture_conversion(less_minus_less id_a targs_a converted),
              conde(and(converted `===` None(),
                        res `===` false.toLogicBool()),
                    freshTypedVars { targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                    and(converted `===` Some(targs_a),
                        conde(freshTypedVars { id_b: Term<LogicInt> targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                              and(conde(type_b `===` Interface(id_b targs_b),
                                        type_b `===` Class_(id_b targs_b)),
                                  class_int_sub(less_minus_less id_a targs_a id_b targs_b res))
                              },
                              freshTypedVars { typ: Term<Jtype<LogicInt>> ->
                              and((type_b `===` Var(_f() _f() _f() Some(typ))),
                                  conde(and(typ `===` type_a,
                                            res `===` true.toLogicBool()),
                                        and(res `===` false.toLogicBool(),
                                            typ `!==` type_a)))
                              },
                              and(res `===` false.toLogicBool(),
                                  (type_b `!==` Var(wildcard() wildcard() wildcard() 
                                                Some(wildcard()))),
                                  (type_b `!==` Interface(wildcard() wildcard())),
                                  (type_b `!==` Class_(wildcard() wildcard())))))
                    }))
          },
          freshTypedVars { id_a: Term<LogicInt> targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> 
            converted: Term<LogicOption<LogicList<Jarg<Jtype<LogicInt>>>>> ->
          and(type_a `===` Interface(id_a targs_a),
              capture_conversion(less_minus_less id_a targs_a converted),
              conde(and(converted `===` None(),
                        res `===` false.toLogicBool()),
                    freshTypedVars { targs_a: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                    and(converted `===` Some(targs_a),
                        conde(freshTypedVars { id_b: Term<LogicInt> targs_b: Term<LogicList<Jarg<Jtype<LogicInt>>>> ->
                              and(type_b `===` Interface(id_b targs_b),
                                  class_int_sub(less_minus_less id_a targs_a id_b targs_b res))
                              },
                              freshTypedVars { typ: Term<Jtype<LogicInt>> ->
                              and((type_b `===` Var(_f() _f() _f() Some(typ))),
                                  conde(and(typ `===` type_a,
                                            res `===` true.toLogicBool()),
                                        and(res `===` false.toLogicBool(),
                                            typ `!==` type_a)))
                              },
                              and(res `===` false.toLogicBool(),
                                  (type_b `!==` Var(wildcard() wildcard() wildcard() 
                                                Some(wildcard()))),
                                  (type_b `!==` Class_(wildcard() wildcard())),
                                  (type_b `!==` Interface(wildcard() wildcard())))))
                    }))
          },
          freshTypedVars { ta: Term<Jtype<LogicInt>> ->
          and(type_a `===` Array_(ta),
              conde(and(ta `===` CT.object_t,
                        conde(and(res `===` true.toLogicBool(),
                                  conde(type_b `===` CT.object_t,
                                        type_b `===` CT.cloneable_t,
                                        type_b `===` CT.serializable_t)),
                              and(type_b `!==` CT.object_t,
                                  type_b `!==` CT.serializable_t,
                                  type_b `!==` CT.cloneable_t,
                                  conde(freshTypedVars { tb: Term<Jtype<LogicInt>> ->
                                        and(type_b `===` Array_(tb),
                                            minus_less_minus(less_minus_less ta tb res))
                                        },
                                        and(res `===` false.toLogicBool(),
                                            (type_b `!==` Array_(wildcard()))))))),
                    and(ta `!==` CT.object_t,
                        conde(freshTypedVars { tb: Term<Jtype<LogicInt>> ->
                              and(type_b `===` Array_(tb),
                                  minus_less_minus(less_minus_less ta tb res))
                              },
                              and(res `===` false.toLogicBool(),
                                  (type_b `!==` Array_(wildcard())))))))
          },
          freshTypedVars { ts: Term<LogicList<Jtype<LogicInt>>> ->
          and(type_a `===` Intersect(ts),
              memo(type_b ts res))
          },
          freshTypedVars { upb_typ: Term<Jtype<LogicInt>> ->
          and((type_a `===` Var(_f() _f() upb_typ _f())),
              conde(and(upb_typ `===` type_b,
                        res `===` true.toLogicBool()),
                    and(res `===` false.toLogicBool(),
                        upb_typ `!==` type_b)))
          },
          and(type_a `===` Null(),
              conde(and(type_b `===` Null(),
                        res `===` false.toLogicBool()),
                    and(res `===` true.toLogicBool(),
                        type_b `!==` Null()))))
  
  }}
// Put epilogue here 
