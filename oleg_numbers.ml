(* Relational arithmentics using binary numbers *)
open OCanren
open OCanren.Std

type injected = int ilogic Std.List.injected

(* let prj_exn : (injected, _) Reifier.t = Std.List.prj_exn OCanren.prj_exn
   let reify : (injected, _) Reifier.t = Std.List.reify OCanren.reify
   let show_logic x = [%show: GT.int OCanren.logic Std.List.logic] () x

   let rec build_num = function
   | 0 -> nil ()
   | n when n mod 2 == 0 -> inj 0 % build_num (n / 2)
   | n -> inj 1 % build_num (n / 2)
   ;;

   let to_int : int Std.List.ground -> int =
   let rec helper base acc = function
   | [] -> acc
   | h :: tl -> helper (base * 2) (acc + (h * base)) tl
   in
   helper 1 0
   ;; *)
(*  *)
[@@@scheme.preamble {|
(define one '(1))
(define zero '())
|}]

[@@@klogic.preamble
{|// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName")

package utils

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import utils.LogicInt.Companion.toLogic

val digitZero: Digit = 0.toLogic()
val digitOne: Digit = 1.toLogic()

typealias Digit = LogicInt
typealias OlegLogicNumber = LogicList<Digit>
typealias OlegTerm = Term<OlegLogicNumber>

val zero: OlegLogicNumber = logicListOf()
val one: OlegLogicNumber = logicListOf( 1.toLogic() )
val three: OlegLogicNumber = logicListOf( 1.toLogic(), 1.toLogic() )

fun UInt.toOlegLogicNumber(): OlegLogicNumber = toLogicList()
fun UInt.toLogicList(): LogicList<Digit> =
    when {
        this == 0u -> nilLogicList()
        this % 2u == 0u -> digitZero + (this / 2u).toLogicList()
        else -> digitOne + (this / 2u).toLogicList()
    }

context(RelationalContext)
fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }
|}]

[@@@klogic.epilogue {|// Put epilogue here |}]
[@@@scheme.epilogue {| |}]

[@@@klogic.type.mangle
[ "int OCanren.ilogic OCanren.Std.List.injected", "OlegTerm"
; "string OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicString>>"
; "int OCanren__.Logic.ilogic", "Term<LogicInt>"
; "string OCanren__.Logic.ilogic", "Term<LogicString>"
; ( "(int OCanren__.Logic.ilogic, int OCanren__.Logic.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "OlegTerm" )
; ( "(int OCanren.ilogic, int OCanren.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "OlegTerm" )
]]

(*  *)

(*
   let poso : int ilogic Std.List.injected -> OCanren.goal =
   fun n st ->
   pause (fun () ->
   let h = State.fresh st in
   let t = State.fresh st in
   (n === h % t) st)
   ;; *)
let full_addero : _ -> _ -> _ -> _ -> _ -> OCanren.goal =
 fun b x y r c ->
  conde
    [ !!0 === b &&& (!!0 === x) &&& (!!0 === y) &&& (!!0 === r) &&& (!!0 === c)
    ; !!1 === b &&& (!!0 === x) &&& (!!0 === y) &&& (!!1 === r) &&& (!!0 === c)
    ; !!0 === b &&& (!!1 === x) &&& (!!0 === y) &&& (!!1 === r) &&& (!!0 === c)
    ; !!1 === b &&& (!!1 === x) &&& (!!0 === y) &&& (!!0 === r) &&& (!!1 === c)
    ; !!0 === b &&& (!!0 === x) &&& (!!1 === y) &&& (!!1 === r) &&& (!!0 === c)
    ; !!1 === b &&& (!!0 === x) &&& (!!1 === y) &&& (!!0 === r) &&& (!!1 === c)
    ; !!0 === b &&& (!!1 === x) &&& (!!1 === y) &&& (!!0 === r) &&& (!!1 === c)
    ; !!1 === b &&& (!!1 === x) &&& (!!1 === y) &&& (!!1 === r) &&& (!!1 === c)
    ]
;;

let zeroo : int ilogic Std.List.injected -> goal = fun n -> n === OCanren.Std.nil ()

let poso : int ilogic Std.List.injected -> OCanren.goal =
 fun n -> fresh (h t) (n === h % t)
;;

(* Appendo is used in multiplication *)
let rec appendo :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> goal
  =
 fun l s out ->
  conde
    [ l === Std.nil () &&& (s === out)
    ; fresh (a d res) (a % d === l) (a % res === out) (appendo d s res)
    ]
;;

let zero : injected = Std.nil ()
let one : injected = !<(!!1)
let three : injected = !!1 % !<(!!1)

let gt1o : int ilogic Std.List.injected -> goal =
 fun n -> fresh (a ad dd) (n === a % (ad % dd))
;;

(* let check1 : _ -> _ -> _ -> OCanren.goal =
   fun b x c ->
   conde
   [ !!0 === b &&& (!!0 === x) &&& (!!0 === c)
    ; !!1 === b &&& (!!0 === x) &&& (!!0 === c)
    ; !!0 === b &&& (!!1 === x) &&& (!!0 === c)
    ]
   ;; *)

(** Satisfies [b] + [x] + [y] = [r] + 2 * [c] *)

(** Adds a carry-in bit [d] to arbitrarily large numbers [n] and [m] to produce a number [r]. *)

let rec addero :
   _
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun d n m r ->
  conde
    [ !!0 === d &&& (m === nil ()) &&& (n === r)
    ; !!0 === d &&& (n === nil ()) &&& (m === r) &&& poso m
    ; !!1 === d &&& (m === nil ()) &&& delay (fun () -> addero !!0 n one r)
    ; !!1 === d &&& (n === nil ()) &&& poso m &&& delay (fun () -> addero !!0 m one r)
    ; n
      === one
      &&& (m === one)
      &&& fresh (a c) (a % (c % Std.nil ()) === r) (full_addero d !!1 !!1 a c)
    ; n === one &&& gen_addero d n m r
    ; m === one &&& gt1o n &&& gt1o r &&& delay (fun () -> addero d one n r)
    ; gt1o n &&& gen_addero d n m r
    ]

and gen_addero :
   _
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun d n m r ->
  fresh
    (a b c e x y z)
    (a % x === n)
    (b % y === m)
    (poso y)
    (c % z === r)
    (poso z)
    (full_addero d a b c e)
    (addero e x y z)
;;

let pluso n m k = addero !!0 n m k
let minuso n m k = pluso m k n

let rec bound_multo :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun q p n m ->
  conde
    [ q === zero &&& poso p
    ; fresh
        (a0 a1 a2 a3 x y z)
        (q === a0 % x)
        (p === a1 % y)
        (conde
           [ n === zero &&& (m === a2 % z) &&& bound_multo x y z zero
           ; n === a3 % z &&& bound_multo x y z m
           ])
    ]
;;

let rec multo :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun n m p ->
  conde
    [ n === zero &&& (p === zero)
    ; poso n &&& (m === zero) &&& (p === zero)
    ; n === one &&& poso m &&& (m === p)
    ; gt1o n &&& (m === one) &&& (n === p)
    ; fresh (x z) (n === !!0 % x) (poso x) (p === !!0 % z) (poso z) (gt1o m) (multo x m z)
    ; fresh (x y) (n === !!1 % x) (poso x) (m === !!0 % y) (poso y) (multo m n p)
    ; fresh (x y) (n === !!1 % x) (poso x) (m === !!1 % y) (poso y) (odd_multo x n m p)
    ]

and odd_multo :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun x n m p -> fresh q (bound_multo q p n m) (multo x m q) (pluso (!!0 % q) m p)
;;

(** have the same length *)
let rec eqlo :
  int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n m ->
  conde
    [ n === zero &&& (m === zero)
    ; n === one &&& (m === one)
    ; fresh (a x b y) (a % x === n) (poso x) (b % y === m) (poso y) (eqlo x y)
    ]
;;

(** [n] has smaller length than [m] *)
let rec ltlo :
  int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n m ->
  conde
    [ n === zero &&& poso m
    ; n === one &&& gt1o m
    ; fresh (a x b y) (a % x === n) (poso x) (b % y === m) (poso y) (ltlo x y)
    ]
;;

let lelo : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal =
 fun n m -> conde [ eqlo n m; ltlo n m ]
;;

let lto : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal =
 fun n m -> conde [ ltlo n m; eqlo n m &&& fresh x (poso x) (pluso n x m) ]
;;

let leo : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal =
 fun n m -> conde [ n === m; lto n m ]
;;

(**  Splits a binary numeral at a given length:
  * (split o n r l h) holds if n = 2^{s+1} · l + h where s = ∥r∥ and h < 2^{s+1}.
  *)
let rec splito :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun n r l h ->
  conde
    [ n === zero &&& (h === zero) &&& (l === zero)
    ; fresh (b n_) (n === !!0 % (b % n_)) (r === zero) (h === b % n_) (l === zero)
    ; fresh n_ (n === !!1 % n_) (r === zero) (n_ === h) (l === one)
    ; fresh
        (b n_ a r_)
        (n === !!0 % (b % n_))
        (a % r_ === r)
        (l === zero)
        (splito (b % n_) r_ zero h)
    ; fresh (n_ a r_) (n === !!1 % n_) (r === a % r_) (l === one) (splito n_ r_ zero h)
    ; fresh
        (b n_ a r_ l_)
        (n === b % n_)
        (r === a % r_)
        (l === b % l_)
        (poso l_)
        (splito n_ r_ l_ h)
    ]
;;

(** Satisfies n = m * q + r, with 0 <= r < m. *)
let rec divo :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun n m q r ->
  conde
    [ r === n &&& (q === zero) &&& lto n m
    ; q === one &&& eqlo n m &&& pluso r m n &&& lto r m
    ; ltlo m n
      &&& lto r m
      &&& poso q
      &&& fresh
            (nh nl qh ql qlm qlmr rr rh)
            (splito n r nl nh)
            (splito q r ql qh)
            (conde
               [ nh === zero &&& (qh === zero) &&& minuso nl r qlm &&& multo ql m qlm
               ; poso nh
                 &&& multo ql m qlm
                 &&& pluso qlm r qlmr
                 &&& minuso qlmr nl rr
                 &&& splito rr r zero rh
                 &&& divo nh m qh rh
               ])
    ]
;;

let rec repeated_mul :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun n q nq ->
  conde
    [ poso n &&& (q === zero) &&& (nq === one)
    ; q === one &&& (n === nq)
    ; gt1o q &&& fresh (q1 nq1) (pluso q1 one q) (repeated_mul n q1 nq1) (multo nq1 n nq)
    ]
;;

let rec exp2 :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun n b q ->
  conde
    [ n === one &&& (q === zero)
    ; gt1o n &&& (q === one) &&& fresh s (splito n b s one)
    ; fresh
        (q1 b2)
        (q === !!0 % q1)
        (poso q1)
        (ltlo b n)
        (appendo b (!!1 % b) b2)
        (exp2 n b2 q1)
    ; fresh
        (q1 nh b2 s)
        (q === !!1 % q1)
        (poso q1)
        (poso nh)
        (splito n b s nh)
        (appendo b (!!1 % b) b2)
        (exp2 nh b2 q1)
    ]
;;

(** Satisfies n = b ^ q + r, where 0 <= r <= n and q is the largest. *)
let logo :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun n b q r ->
  conde
    [ n === one &&& poso b &&& (q === zero) &&& (r === zero)
    ; q === zero &&& lto n b &&& pluso r one n
    ; q === one &&& gt1o b &&& eqlo n b &&& pluso r b n
    ; b === one &&& poso q &&& pluso r one n
    ; b === zero &&& poso q &&& (r === n)
    ; !!0 % (!!1 % Std.nil ())
      === b
      &&& fresh
            (a ad dd)
            (poso dd)
            (n === a % (ad % dd))
            (exp2 n (nil ()) q)
            (fresh s (splito n dd r s))
    ; fresh (a ad add ddd) (conde [ b === three; b === a % (ad % (add % ddd)) ])
      &&& ltlo b n
      &&& fresh
            (bw1 bw nw nw1 ql1 ql s)
            (exp2 b zero bw1)
            (pluso bw1 one bw)
            (ltlo q n)
            (fresh (q1 bwq1) (pluso q one q1) (multo bw q1 bwq1) (lto nw1 bwq1))
            (exp2 n zero nw1)
            (pluso nw1 one nw)
            (divo nw bw ql1 s)
            (pluso ql one ql1)
            (lelo ql q)
            (fresh
               (bql qh s2 qdh qd)
               (repeated_mul b ql bql)
               (divo nw bw1 qh s2)
               (pluso ql qdh qh)
               (pluso ql qd q)
               (leo qd qdh)
               (fresh
                  (bqd bq1 bq)
                  (repeated_mul b qd bqd)
                  (multo bql bqd bq)
                  (multo b bq bq1)
                  (pluso bq r n)
                  (lto n bq1)))
    ]
;;

let expo :
   int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected
  -> OCanren.goal
  =
 fun b q n -> logo n b q zero
;;

(* let test17 n m = lelo n m &&& multo n (build_num 2) m
let test27 b q r = logo (build_num 68) b q r &&& gt1o q
let show_num = GT.(show List.ground @@ show int)
*)
(* let _ffoo _ =
   run_exn show_num (-1)  qr qrh (REPR (fun q r     -> multo q r (build_num 1)                          ));
   run_exn show_num (-1)   q  qh (REPR (fun q       -> multo (build_num 7) (build_num 63) q             ));
   run_exn show_num (-1)  qr qrh (REPR (fun q r     -> divo (build_num 3) (build_num 2) q r             ));
   run_exn show_num (-1)   q  qh (REPR (fun q       -> logo (build_num 14) (build_num 2) (build_num 3) q));
   run_exn show_num (-1)   q  qh (REPR (fun q       -> expo (build_num 3) (build_num 5) q               ));
   () *)
