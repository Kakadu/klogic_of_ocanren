(* Relational arithmentics using binary numbers *)
open OCanren
open OCanren.Std

type injected = int ilogic Std.List.injected

(* let prj_exn : (injected, _) Reifier.t = Std.List.prj_exn OCanren.prj_exn
let reify : (injected, _) Reifier.t = Std.List.reify OCanren.reify
let show_logic x = [%show: GT.int OCanren.logic Std.List.logic] () x

let rec build_num = function
  | 0 -> nil ()
  | n when n mod 2 == 0 -> inj 0 % build_num (n / 2)
  | n -> inj 1 % build_num (n / 2)
;;

let to_int : int Std.List.ground -> int =
  let rec helper base acc = function
    | [] -> acc
    | h :: tl -> helper (base * 2) (acc + (h * base)) tl
  in
  helper 1 0
;; *)
(*  *)
[@@@klogic.preamble
{|// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName")

package utils

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import utils.LogicInt.Companion.toLogic

val digitZero: Digit = 0.toLogic()
val digitOne: Digit = 1.toLogic()

typealias Digit = LogicInt
typealias OlegLogicNumber = LogicList<Digit>

val zero: OlegLogicNumber = logicListOf()
val one: OlegLogicNumber = logicListOf( 1.toLogic() )
val three: OlegLogicNumber = logicListOf( 1.toLogic(), 1.toLogic() )

fun UInt.toOlegLogicNumber(): OlegLogicNumber = toLogicList()
fun UInt.toLogicList(): LogicList<Digit> =
    when {
        this == 0u -> nilLogicList()
        this % 2u == 0u -> digitZero + (this / 2u).toLogicList()
        else -> digitOne + (this / 2u).toLogicList()
    }

fun <T> pause(f: () -> RecursiveStream<T>): RecursiveStream<T> = ThunkStream(f)

|}]

[@@@klogic.epilogue {|// Put epilogue here |}]

[@@@klogic.type.mangle
[ "int OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicInt>>"
; "int OCanren__.Logic.ilogic", "Term<LogicInt>"
; ( "(int OCanren__.Logic.ilogic, int OCanren__.Logic.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" )
; ( "(int OCanren.ilogic, int OCanren.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" )
]]

(*  *)
let poso : int ilogic Std.List.injected -> OCanren.goal =
 fun n -> fresh (h t) (n === h % t)
;;

(* 
let poso : int ilogic Std.List.injected -> OCanren.goal =
 fun n st ->
  pause (fun () ->
    let h = State.fresh st in
    let t = State.fresh st in
    (n === h % t) st)
;; *)

let zeroo : int ilogic Std.List.injected -> goal = fun n -> n === OCanren.Std.nil ()

(* Appendo is used in multiplication *)
let rec appendo
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> goal
  =
 fun l s out ->
  conde
    [ l === Std.nil () &&& (s === out)
    ; fresh (a d res) (a % d === l) (a % res === out) (appendo d s res)
    ]
;;

(*  

(* let rec appendo l s out st =
  pause
    (fun () ->
      let st = State.new_scope st in
        mplus (bind ((l === (Std.nil ())) st) (s === out))
          (pause
            (fun () ->
              (fun st ->
                pause
                  (fun () ->
                    let a = State.fresh st in
                    let d = State.fresh st in
                    let res = State.fresh st in
                      bind (bind (((a % d) === l) st) ((a % res) === out))
                      (appendo d s res))) st))) *)

let zero : injected = Std.nil ()
let one : injected = !<(!!1)
let three : injected = !!1 % !<(!!1)

let gt1o : int ilogic Std.List.injected -> goal =
 fun n -> fresh (a ad dd) (n === a % (ad % dd))
;;

(* let check1 : _ -> _ -> _ -> OCanren.goal =
 fun b x c ->
  conde
    [ !!0 === b &&& (!!0 === x) &&& (!!0 === c)
    ; !!1 === b &&& (!!0 === x) &&& (!!0 === c)
    ; !!0 === b &&& (!!1 === x) &&& (!!0 === c)
    ]
;; *)

(** Satisfies [b] + [x] + [y] = [r] + 2 * [c]  *)

let full_addero : _ -> _ -> _ -> _ -> _ -> OCanren.goal =
 fun b x y r c ->
  conde
    [ !!0 === b &&& (!!0 === x) &&& (!!0 === y) &&& (!!0 === r) &&& (!!0 === c)
    ; !!1 === b &&& (!!0 === x) &&& (!!0 === y) &&& (!!1 === r) &&& (!!0 === c)
    ; !!0 === b &&& (!!1 === x) &&& (!!0 === y) &&& (!!1 === r) &&& (!!0 === c)
    ; !!1 === b &&& (!!1 === x) &&& (!!0 === y) &&& (!!0 === r) &&& (!!1 === c)
    ; !!0 === b &&& (!!0 === x) &&& (!!1 === y) &&& (!!1 === r) &&& (!!0 === c)
    ; !!1 === b &&& (!!0 === x) &&& (!!1 === y) &&& (!!0 === r) &&& (!!1 === c)
    ; !!0 === b &&& (!!1 === x) &&& (!!1 === y) &&& (!!0 === r) &&& (!!1 === c)
    ; !!1 === b &&& (!!1 === x) &&& (!!1 === y) &&& (!!1 === r) &&& (!!1 === c)
    ]
;;

(** Satisfies [b] + [x] + [y] = [r] + 2 * [c]  *)
(*
let full_addero b x y r c st =
  log
    "\tfull_addero %s %s %s %s %s (REIFIED)\n"
    (bit_trace_after_reify b st)
    (bit_trace_after_reify x st)
    (bit_trace_after_reify y st)
    (bit_trace_after_reify r st)
    (bit_trace_after_reify c st);
  pause (fun () ->
    log "  full_addero after pause 1\n";
    let st = State.new_scope st in
    mplus
      (bind
         (bind (bind (bind ((!0 === b) st) (!0 === x)) (!0 === y)) (!0 === r))
         (!0 === c))
      (pause (fun () ->
        log "  full_addero after pause 2\n";
         mplus
           (bind
              (bind (bind (bind ((!1 === b) st) (!0 === x)) (!0 === y)) (!1 === r))
              (!0 === c))
           (pause (fun () ->
             log "  full_addero after pause 3\n";
              mplus
                (bind
                   (bind
                      (bind (bind ((!0 === b) st) (!1 === x)) (!0 === y))
                      (!1 === r))
                   (!0 === c))
                (pause (fun () ->
                  log "  full_addero after pause 4\n";
                   mplus
                     (bind
                        (bind
                           (bind (bind ((!1 === b) st) (!1 === x)) (!0 === y))
                           (!0 === r))
                        (!1 === c))
                     (pause (fun () ->
                      log "  full_addero after pause 5\n";
                        mplus
                          (bind
                             (bind
                                (bind (bind ((!0 === b) st) (!0 === x)) (!1 === y))
                                (!1 === r))
                             (!0 === c))
                          (pause (fun () ->
                            log "  full_addero after pause 6\n";
                             mplus
                               (bind
                                  (bind
                                     (bind
                                        (bind ((!1 === b) st) (!0 === x))
                                        (!1 === y))
                                     (!0 === r))
                                  (!1 === c))
                               (pause (fun () ->
                                log "  full_addero after pause 7\n";
                                  mplus
                                    (bind
                                       (bind
                                          (bind
                                             (bind ((!0 === b) st) (!1 === x))
                                             (!1 === y))
                                          (!0 === r))
                                       (!1 === c))
                                    (pause (fun () ->
                                       log "  full_addero after pause 8\n";
                                       bind
                                         (bind
                                            (bind
                                               (bind ((!1 === b) st) (!1 === x))
                                               (!1 === y))
                                            (!1 === r))
                                         (!1 === c))))))))))))))))
;; *)

(** Adds a carry-in bit [d] to arbitrarily large numbers [n] and [m] to produce a number [r]. *)
let rec addero
  :  _ -> int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun d n m r ->
  conde
    [ !!0 === d &&& (m === nil ()) &&& (n === r)
    ; !!0 === d &&& (n === nil ()) &&& (m === r) &&& poso m
    ; !!1 === d &&& (m === nil ()) &&& addero !!0 n one r
    ; !!1 === d &&& (n === nil ()) &&& poso m &&& addero !!0 m one r
    ; n
      === one
      &&& (m === one)
      &&& fresh (a c) (a % (c % Std.nil ()) === r) (full_addero d !!1 !!1 a c)
    ; n === one &&& gen_addero d n m r
    ; m === one &&& gt1o n &&& gt1o r &&& addero d one n r
    ; gt1o n &&& gen_addero d n m r
    ]

and gen_addero
  :  _ -> int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun d n m r ->
  fresh
    (a b c e x y z)
    (a % x === n)
    (b % y === m)
    (poso y)
    (c % z === r)
    (poso z)
    (full_addero d a b c e)
    (addero e x y z)
;;

(** Adds a carry-in bit [d] to arbitrarily large numbers [n] and [m] to produce a number [r]. *)
(* let rec addero d n m r st =
  pause (fun () ->
    log "  addero after 1st pause\n";
    let st = State.new_scope st in
    mplus
      (bind
         (bind ((( === ) ~s:"50" !0 d) st) (( === ) ~s:"51" (nil ()) m))
         (( === ) ~s:"52" n r))
      (pause (fun () ->
         log "  addero after 2nd pause\n";
         mplus
           (bind
              (bind
                 (bind ((( === ) ~s:"53" !0 d) st) (( === ) ~s:"54" (nil ()) n))
                 (( === ) ~s:"55" m r))
              (poso m))
           (pause (fun () ->
              log "  addero after 3rd pause\n";
              mplus
                (bind
                   (bind ((( === ) ~s:"56" !1 d) st) (nil () === m))
                   (addero !0 n one r))
                (pause (fun () ->
                   log "  addero after 4th pause\n";
                   mplus
                     (bind
                        (bind
                           (bind ((!1 === d) st) (( === ) ~s:"59" (nil ()) n))
                           (poso m))
                        (addero !0 m one r))
                     (pause (fun () ->
                        log "  addero after 5th pause\n";
                        mplus
                          (bind
                             (bind ((( === ) ~s:"60" n one) st) (( === ) ~s:"61" m one))
                             (fun st ->
                               pause (fun () ->
                                 log "  addero after 6th pause\n";
                                 let a = State.fresh st in
                                 let c = State.fresh st in
                                 bind
                                   ((( === ) ~s:"62" (a %< c) r) st)
                                   (full_addero d !1 !1 a c))))
                          (pause (fun () ->
                             log "  addero after 7th pause\n";
                             mplus
                               (bind ((( === ) ~s:"63" n one) st) (gen_addero d n m r))
                               (pause (fun () ->
                                log "  addero after 8th pause\n";
                                  mplus
                                    (bind
                                       (bind
                                          (bind ((( === ) ~s:"64" m one) st) (gt1o n))
                                          (gt1o r))
                                       (addero d one n r))
                                    (pause (fun () ->
                                       log "  addero after 9th pause\n";
                                       bind ((gt1o n) st) (gen_addero d n m r))))))))))))))))

and gen_addero d n m r st =
  pause (fun () ->
    let a = State.fresh st in
    let b = State.fresh st in
    let c = State.fresh st in
    let e = State.fresh st in
    let x = State.fresh st in
    let y = State.fresh st in
    let z = State.fresh st in
    log
      "  a = %s, b = %s, c = %s, e = %s, x = %s, y = %s, z = %s gen_addero\n"
      (bit_trace_after_reify a st)
      (bit_trace_after_reify b st)
      (bit_trace_after_reify c st)
      (bit_trace_after_reify e st)
      (trace_after_reify x st)
      (trace_after_reify y st)
      (trace_after_reify z st);
    bind
      (bind
         (bind
            (bind
               (bind
                  (bind ((( === ) ~s:"30" (a % x) n) st) (( === ) ~s:"31" (b % y) m))
                  (poso y))
               (( === ) ~s:"32" (c % z) r))
            (poso z))
         (full_addero d a b c e))
      (addero e x y z))
;;
 *)

let pluso n m k = addero !!0 n m k
let minuso n m k = pluso m k n

let rec bound_multo
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun q p n m ->
  conde
    [ q === zero &&& poso p
    ; fresh
        (a0 a1 a2 a3 x y z)
        (q === a0 % x)
        (p === a1 % y)
        (conde
           [ n === zero &&& (m === a2 % z) &&& bound_multo x y z zero
           ; n === a3 % z &&& bound_multo x y z m
           ])
    ]
;;

let rec multo
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n m p ->
  conde
    [ n === zero &&& (p === zero)
    ; poso n &&& (m === zero) &&& (p === zero)
    ; n === one &&& poso m &&& (m === p)
    ; gt1o n &&& (m === one) &&& (n === p)
    ; fresh (x z) (n === !!0 % x) (poso x) (p === !!0 % z) (poso z) (gt1o m) (multo x m z)
    ; fresh (x y) (n === !!1 % x) (poso x) (m === !!0 % y) (poso y) (multo m n p)
    ; fresh (x y) (n === !!1 % x) (poso x) (m === !!1 % y) (poso y) (odd_multo x n m p)
    ]

and odd_multo
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun x n m p -> fresh q (bound_multo q p n m) (multo x m q) (pluso (!!0 % q) m p)
;;

(*
let rec bound_multo q p n m st =
  (* Printf.printf "bound_multo %s %s %s %s\n" (traceP q) (traceP p) (traceP n) (traceP m); *)
  Printf.printf
    "\tbound_multo %s %s %s %s (REIFIED)\n"
    (trace_after_reify q st)
    (trace_after_reify p st)
    (trace_after_reify n st)
    (trace_after_reify m st);
  pause (fun () ->
    let st = State.new_scope st in
    mplus
      (bind ((q === zero) st) (poso p))
      (pause (fun () ->
         (fun st ->
           pause (fun () ->
             let a0 = State.fresh st in
             let a1 = State.fresh st in
             let a2 = State.fresh st in
             let a3 = State.fresh st in
             let x = State.fresh st in
             let y = State.fresh st in
             let z = State.fresh st in
             Printf.printf
               "  a0 = %s, a1 = %s, a2 = %s, a3 = %s BOUND_MULTO\n"
               (bit_trace_after_reify a0 st)
               (bit_trace_after_reify a1 st)
               (bit_trace_after_reify a2 st)
               (bit_trace_after_reify a3 st);
             bind
               (bind ((( === ) ~s:"20" q (a0 % x)) st) (( === ) ~s:"21" p (a1 % y)))
               (fun st ->
                 pause (fun () ->
                   let st = State.new_scope st in
                   mplus
                     (bind
                        (bind ((( === ) ~s:"22" n zero) st) (( === ) ~s:"23" m (a2 % z)))
                        (bound_multo x y z zero))
                     (pause (fun () ->
                        bind ((( === ) ~s:"24" n (a3 % z)) st) (bound_multo x y z m)))))))
           st)))
;;

let rec multo n m p st =
  (* Printf.printf "multo %s %s %s\n" (traceP n) (traceP m) (traceP p); *)
  Printf.printf
    "\tmulto %s %s %s (REIFIED)\n"
    (trace_after_reify n st)
    (trace_after_reify m st)
    (trace_after_reify p st);
  pause (fun () ->
    Printf.printf "\tmulto after 1st pause\n";
    let st = State.new_scope st in
    mplus
      (bind ((( === ) ~s:"1" n zero) st) (( === ) ~s:"2" p zero))
      (pause (fun () ->
         Printf.printf "\tmulto after 2nd pause\n";
         mplus
           (bind (bind ((poso n) st) (( === ) ~s:"3" m zero)) (( === ) ~s:"4" p zero))
           (pause (fun () ->
              mplus
                (bind (bind ((( === ) ~s:"5" n one) st) (poso m)) (( === ) ~s:"6" m p))
                (pause (fun () ->
                   mplus
                     (bind
                        (bind ((gt1o n) st) (( === ) ~s:"7" m one))
                        (( === ) ~s:"8" n p))
                     (pause (fun () ->
                        mplus
                          ((fun st ->
                             pause (fun () ->
                               let x = State.fresh st in
                               let z = State.fresh st in
                               Printf.printf
                                 "  x = %s, z = %s\n"
                                 (trace_after_reify x st)
                                 (trace_after_reify z st);
                               bind
                                 (bind
                                    (bind
                                       (bind
                                          (bind ((( === ) n ~s:"9" (!0 % x)) st) (poso x))
                                          (( === ) p (!0 % z) ~s:"10"))
                                       (poso z))
                                    (gt1o m))
                                 (multo x m z)))
                             st)
                          (pause (fun () ->
                             mplus
                               ((fun st ->
                                  pause (fun () ->
                                    let x = State.fresh st in
                                    let y = State.fresh st in
                                    Printf.printf
                                      "  x = %s, y = %s AAA\n"
                                      (trace_after_reify x st)
                                      (trace_after_reify y st);
                                    bind
                                      (bind
                                         (bind
                                            (bind
                                               ((( === ) n (!1 % x) ~s:"11") st)
                                               (poso x))
                                            (( === ) ~s:"12" m (!0 % y)))
                                         (poso y))
                                      (multo m n p)))
                                  st)
                               (pause (fun () ->
                                  (fun st ->
                                    pause (fun () ->
                                      let x = State.fresh st in
                                      let y = State.fresh st in
                                      Printf.printf
                                        "  x = %s, y = %s BBB\n"
                                        (trace_after_reify x st)
                                        (trace_after_reify y st);
                                      bind
                                        (bind
                                           (bind
                                              (bind
                                                 ((( === ) n (!1 % x) ~s:"13") st)
                                                 (poso x))
                                              (( === ) m (!1 % y) ~s:"14"))
                                           (poso y))
                                        (odd_multo x n m p)))
                                    st)))))))))))))

and odd_multo x n m p st =
  (* Printf.printf "odd_multo %s %s %s %s\n" (traceP x) (traceP n) (traceP m) (traceP p); *)
  Printf.printf
    "\todd_multo %s %s %s %s (REIFIED)\n"
    (trace_after_reify x st)
    (trace_after_reify n st)
    (trace_after_reify m st)
    (trace_after_reify p st);
  pause (fun () ->
    let q = State.fresh st in
    let head = (bound_multo q p n m) st in
    bind (bind head (multo x m q)) (pluso (!0 % q) m p))
;; *)

(** have the same length *)
let rec eqlo
  : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n m ->
  conde
    [ n === zero &&& (m === zero)
    ; n === one &&& (m === one)
    ; fresh (a x b y) (a % x === n) (poso x) (b % y === m) (poso y) (eqlo x y)
    ]
;;

(** [n] has smaller length than [m] *)
let rec ltlo
  : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n m ->
  conde
    [ n === zero &&& poso m
    ; n === one &&& gt1o m
    ; fresh (a x b y) (a % x === n) (poso x) (b % y === m) (poso y) (ltlo x y)
    ]
;;

let lelo : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal =
 fun n m -> conde [ eqlo n m; ltlo n m ]
;;

let lto : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal =
 fun n m -> conde [ ltlo n m; eqlo n m &&& fresh x (poso x) (pluso n x m) ]
;;

let leo : int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal =
 fun n m -> conde [ n === m; lto n m ]
;;

(**  Splits a binary numeral at a given length:
  * (split o n r l h) holds if n = 2^{s+1} · l + h where s = ∥r∥ and h < 2^{s+1}.
  *)
let rec splito
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n r l h ->
  conde
    [ n === zero &&& (h === zero) &&& (l === zero)
    ; fresh (b n_) (n === !!0 % (b % n_)) (r === zero) (h === b % n_) (l === zero)
    ; fresh n_ (n === !!1 % n_) (r === zero) (n_ === h) (l === one)
    ; fresh
        (b n_ a r_)
        (n === !!0 % (b % n_))
        (a % r_ === r)
        (l === zero)
        (splito (b % n_) r_ zero h)
    ; fresh (n_ a r_) (n === !!1 % n_) (r === a % r_) (l === one) (splito n_ r_ zero h)
    ; fresh
        (b n_ a r_ l_)
        (n === b % n_)
        (r === a % r_)
        (l === b % l_)
        (poso l_)
        (splito n_ r_ l_ h)
    ]
;;

(** Satisfies n = m * q + r, with 0 <= r < m. *)
let rec divo
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n m q r ->
  conde
    [ r === n &&& (q === zero) &&& lto n m
    ; q === one &&& eqlo n m &&& pluso r m n &&& lto r m
    ; ltlo m n
      &&& lto r m
      &&& poso q
      &&& fresh
            (nh nl qh ql qlm qlmr rr rh)
            (splito n r nl nh)
            (splito q r ql qh)
            (conde
               [ nh === zero &&& (qh === zero) &&& minuso nl r qlm &&& multo ql m qlm
               ; poso nh
                 &&& multo ql m qlm
                 &&& pluso qlm r qlmr
                 &&& minuso qlmr nl rr
                 &&& splito rr r zero rh
                 &&& divo nh m qh rh
               ])
    ]
;;

let rec repeated_mul
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n q nq ->
  conde
    [ poso n &&& (q === zero) &&& (nq === one)
    ; q === one &&& (n === nq)
    ; gt1o q &&& fresh (q1 nq1) (pluso q1 one q) (repeated_mul n q1 nq1) (multo nq1 n nq)
    ]
;;

let rec exp2
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n b q ->
  conde
    [ n === one &&& (q === zero)
    ; gt1o n &&& (q === one) &&& fresh s (splito n b s one)
    ; fresh
        (q1 b2)
        (q === !!0 % q1)
        (poso q1)
        (ltlo b n)
        (appendo b (!!1 % b) b2)
        (exp2 n b2 q1)
    ; fresh
        (q1 nh b2 s)
        (q === !!1 % q1)
        (poso q1)
        (poso nh)
        (splito n b s nh)
        (appendo b (!!1 % b) b2)
        (exp2 nh b2 q1)
    ]
;;

(** Satisfies n = b ^ q + r, where 0 <= r <= n and q is the largest. *)
let logo
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun n b q r ->
  conde
    [ n === one &&& poso b &&& (q === zero) &&& (r === zero)
    ; q === zero &&& lto n b &&& pluso r one n
    ; q === one &&& gt1o b &&& eqlo n b &&& pluso r b n
    ; b === one &&& poso q &&& pluso r one n
    ; b === zero &&& poso q &&& (r === n)
    ; !!0 % (!!1 % Std.nil ())
      === b
      &&& fresh
            (a ad dd)
            (poso dd)
            (n === a % (ad % dd))
            (exp2 n (nil ()) q)
            (fresh s (splito n dd r s))
    ; fresh (a ad add ddd) (conde [ b === three; b === a % (ad % (add % ddd)) ])
      &&& ltlo b n
      &&& fresh
            (bw1 bw nw nw1 ql1 ql s)
            (exp2 b zero bw1)
            (pluso bw1 one bw)
            (ltlo q n)
            (fresh (q1 bwq1) (pluso q one q1) (multo bw q1 bwq1) (lto nw1 bwq1))
            (exp2 n zero nw1)
            (pluso nw1 one nw)
            (divo nw bw ql1 s)
            (pluso ql one ql1)
            (lelo ql q)
            (fresh
               (bql qh s2 qdh qd)
               (repeated_mul b ql bql)
               (divo nw bw1 qh s2)
               (pluso ql qdh qh)
               (pluso ql qd q)
               (leo qd qdh)
               (fresh
                  (bqd bq1 bq)
                  (repeated_mul b qd bqd)
                  (multo bql bqd bq)
                  (multo b bq bq1)
                  (pluso bq r n)
                  (lto n bq1)))
    ]
;;

let expo
  :  int ilogic Std.List.injected -> int ilogic Std.List.injected
  -> int ilogic Std.List.injected -> OCanren.goal
  =
 fun b q n -> logo n b q zero
;;

(* let test17 n m = lelo n m &&& multo n (build_num 2) m
let test27 b q r = logo (build_num 68) b q r &&& gt1o q
let show_num = GT.(show List.ground @@ show int)

 *)
(* let _ffoo _ =
  run_exn show_num (-1)  qr qrh (REPR (fun q r     -> multo q r (build_num 1)                          ));
  run_exn show_num (-1)   q  qh (REPR (fun q       -> multo (build_num 7) (build_num 63) q             ));
  run_exn show_num (-1)  qr qrh (REPR (fun q r     -> divo (build_num 3) (build_num 2) q r             ));
  run_exn show_num (-1)   q  qh (REPR (fun q       -> logo (build_num 14) (build_num 2) (build_num 3) q));
  run_exn show_num (-1)   q  qh (REPR (fun q       -> expo (build_num 3) (build_num 5) q               ));
  () *)

(* let num_reifier h = List.reify OCanren.reify h *)
(* let runL n = run_r num_reifier show_num_logic n *)
 *)
