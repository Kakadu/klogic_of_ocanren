open OCanren

[@@@ocaml.warning "-32-33"]

type jtype_injected = int OCanren.ilogic
type decl_injected = int OCanren.ilogic

[@@@klogic.preamble
{|// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName")

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import utils.LogicInt
import utils.LogicOption
//import utils.None

typealias Decl = LogicInt
typealias JType = LogicInt

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }
|}]

[@@@klogic.epilogue {|// Put epilogue here |}]

[@@@klogic.type.mangle
[ "int OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicInt>>"
; "string OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicString>>"
; "int OCanren__.Logic.ilogic", "Term<LogicInt>"
; "int OCanren.ilogic", "LogicInt"
; "string OCanren__.Logic.ilogic", "LogicString"
  (* ; ( "(int OCanren__.Logic.ilogic, int OCanren__.Logic.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" )
; ( "(int OCanren.ilogic, int OCanren.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" ) *)
; "jtype_injected", "JType"
; "decl_injected", "Decl"
; "Polarity.t ilogic", "Polarity"
; "jtype_injected OCanren.Std.Option.injected", "Term<LogicOption<JType>>"
; "OCanren.goal", "Goal"
; "Targ.injected", "Targ"
; "Jtype.injected", "Jtype"
; "Polarity.injected", "Polarity"
; "Polarity.t", "Polarity"
; "OCanren.Std.Pair.injected", "LogicPair"
; "OCanren.Std.Nat.injected", "PeanoLogicNumber"
; "OCanren.Std.Option.injected", "LogicOption"
  (* ; ( "('id OCanren.ilogic, 'id OCanren.ilogic Jtype.injected Targ.injected \
     OCanren.Std.List.injected, OCanren.Std.Nat.injected, 'id OCanren.ilogic \
     Jtype.injected, 'id OCanren.ilogic Jtype.injected OCanren.Std.Option.injected, 'id \
     OCanren.ilogic Jtype.injected OCanren.Std.List.injected)Jtype.t \
     OCanren__.Logic.ilogic"
  , "FUCK" ) *)
]]

(* let conso1 : int ilogic Std.List.injected -> goal =
 fun xs -> fresh (h tl) (xs === Std.List.cons h tl)
;; *)

(* let nilo1 : int ilogic Std.List.injected -> goal = fun xs -> xs === Std.List.nil () *)
(* let nilo2 : int ilogic Std.List.injected -> goal = fun xs -> xs =/= Std.List.cons __ __ *)

(* module type CT = sig
  val decl_by_id : (int ilogic -> OCanren.goal) -> decl_injected -> OCanren.goal

  val get_superclass
    :  (int ilogic -> OCanren.goal)
    -> (int ilogic -> OCanren.goal)
    -> jtype_injected Std.Option.injected
    -> OCanren.goal

  (* val object_t : jtype_injected -> OCanren.goal
     val cloneable_t : jtype_injected -> OCanren.goal
     val serializable_t : jtype_injected -> OCanren.goal *)
  val new_var : (int OCanren.ilogic -> OCanren.goal) -> int ilogic -> OCanren.goal
end

module type STUFF = sig end

module Stuff (Impl : CT) : STUFF = struct
  let not_a_superclass : int ilogic -> int ilogic -> goal =
   fun a b -> Impl.get_superclass (fun x -> x === a) (fun x -> x === b) (Std.none ())
 ;;
end *)

(* let rec mapo
  :  ('a ilogic -> 'b ilogic -> goal) -> 'a ilogic Std.List.injected
  -> 'b ilogic Std.List.injected -> goal
  =
 fun f xs ys ->
  conde
    [ xs === Std.nil () &&& (ys === Std.nil ())
    ; fresh
        (h tl tmph tmptl)
        (xs === Std.List.cons h tl)
        (ys === Std.(tmph % tmptl))
        (f h tmph)
        (mapo f tl tmptl)
    ]
;; *)

(* let appo : ('a ilogic -> goal) -> 'a ilogic -> goal = fun f x -> f x *)
(* let five : (int ilogic -> goal) -> goal = fun f -> f !!5 *)

module Polarity = struct
  [%%distrib
  type nonrec ground =
    | Extends
    | Super
  [@@deriving gt ~options:{ show; fmt; gmap }]]
end
[@@skip_from_klogic]

module Targ = struct
  [%%distrib
  type nonrec 'jtype ground =
    | Type of 'jtype
    | Wildcard of (Polarity.ground * 'jtype) Std.Option.ground
  [@@deriving gt ~options:{ show; fmt; gmap }]]

  let type_ t : _ ilogic injected = !!(Type t)
  let wildcard t : _ injected = !!(Wildcard t)
end
[@@skip_from_klogic]

module Jtype = struct
  [%%distrib
  type 'id ground =
    | Array of 'id ground
    | Class of 'id * 'id ground Targ.ground Std.List.ground
    | Interface of 'id * 'id ground Targ.ground Std.List.ground
    | Var of
        { id : 'id
        ; index : Std.Nat.ground
        ; upb : 'id ground
        ; lwb : 'id ground Std.Option.ground
        }
    | Null
    | Intersect of 'id ground Std.List.ground
  [@@deriving gt ~options:{ show; fmt; gmap }]]

  let array a : _ injected = !!(Array a)
  let class_ a b : _ injected = !!(Class (a, b))
  let interface a b : _ injected = !!(Interface (a, b))
  let var id index upb lwb : _ injected = !!(Var { id; index; upb; lwb })
  let intersect a : _ injected = !!(Intersect a)
end
[@@skip_from_klogic]

open Jtype
open Targ

let dummy : 'id ilogic Jtype.injected -> goal =
 fun typ ->
  conde
    [ fresh a (typ === array a)
    ; fresh (a b) (typ === class_ a b)
    ; fresh (a b c d) (typ === var a b c d)
    ]
;;

let rec substitute_typ :
          'id.
          ('id ilogic Jtype.injected Targ.injected Std.List.injected -> goal)
          -> ('id ilogic Jtype.injected -> goal)
          -> 'id ilogic Jtype.injected
          -> OCanren.goal
  =
 fun subst q0 q30 ->
  fresh
    q3
    (q0 q3)
    (conde
       [ fresh
           (typ q4)
           (q3 === array typ)
           (q30 === array q4)
           (substitute_typ subst (( === ) typ) q4)
       ; fresh
           (id args q8)
           (q3 === class_ id args)
           (q30 === class_ id q8)
           (List.HO.map
              (fun a b -> substitute_arg subst a b)
              (fun eta -> eta === args)
              q8)
       ; fresh
           (id args q13)
           (q3 === interface id args)
           (q30 === interface id q13)
           (List.HO.map
              (fun a b -> substitute_arg subst a b)
              (fun eta -> eta === args)
              q13)
       ; fresh
           (typs q17)
           (q3 === intersect typs)
           (q30 === intersect q17)
           (List.HO.map
              (fun a b -> substitute_typ subst a b)
              (fun eta -> eta === typs)
              q17)
       ; fresh () (q3 === !!Null) (q30 === !!Null)
       ])

and substitute_arg :
      'id.
      ('id ilogic Jtype.injected Targ.injected Std.List.injected -> goal)
      -> ('id ilogic Jtype.injected Targ.injected -> goal)
      -> 'id ilogic Jtype.injected Targ.injected
      -> goal
  =
 fun subst q34 q63 ->
  fresh
    q37
    (q34 q37)
    (conde
       [ fresh
           (q38 index q39 q40)
           (q37 === type_ (var q38 index q39 q40))
           (List.HO.nth subst (( === ) index) q63)
       ; fresh
           (typ q48)
           (q37 === type_ typ)
           (q63 === type_ q48)
           (* (q37 =/= (type_ (var __ __ __ __))) *)
           (substitute_typ subst (fun eta -> typ === eta) q48)
       ; fresh () (q37 === wildcard (Std.none ())) (q63 === wildcard (Std.none ()))
         (* (q37 =/= (type_ __)) *)
         (* (q37 =/= (type_ (var __ __ __ __))) *)
       ; fresh
           (p typ q58 q59)
           (q37 === wildcard (Std.some (Std.pair p typ)))
           (q63 === wildcard (Std.some (Std.pair q58 q59)))
           (p === q58)
           (q37 =/= wildcard (Std.none ()))
           (* (q37 =/= (type_ __)) *)
           (* (q37 =/= (type_ (var __ __ __ __))) *)
           (substitute_typ subst (fun eta -> typ === eta) q59)
       ])
;;
