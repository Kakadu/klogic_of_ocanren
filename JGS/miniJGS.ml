open OCanren

[@@@ocaml.warning "-32-33"]

type jtype_injected = int OCanren.ilogic
type decl_injected = int OCanren.ilogic

[@@@klogic.preamble
{|// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName"
  , "PropertyName", "ClassName", "LocalVariableName"
  )

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import org.klogic.utils.terms.PeanoLogicNumber
import org.klogic.utils.terms.NextNaturalNumber
import org.klogic.utils.terms.ZeroNaturalNumber
import org.klogic.utils.terms.LogicPair
import utils.LogicInt
import utils.Some
import utils.None
import utils.LogicOption
//import utils.None

typealias Decl = LogicInt
typealias JType = LogicInt

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }
@Suppress("UNUSED_PARAMETER")
fun <A: Term<A>> wc(f : (Term<A>) -> Goal ) : Goal = success
|}]

[@@@klogic.epilogue {|// Put epilogue here |}]

(*  *)
[@@@klogic.ident.mangle
[ "OCanren.Std.pair", "LogicPair"
; "OCanren.Std.some", "Some"
; "Targ.wildcard", "Wildcard"
; "Targ.type_", "Type"
; "Jtype.class_", "Class_"
; "Jtype.array", "Array_"
; "Jtype.var", "Var"
; "Jtype.interface", "Interface"
; "Jtype.intersect", "Intersect"
; "Jtype.null", "Null"
; "List.HO.nth", "list_ho_nth"
; "List.HO.map", "list_ho_map"
; "OCanren.Std.Nat.zero", "ZeroNaturalNumber"
; "OCanren.Std.Nat.succ", "NextNaturalNumber"
; "", ""
]]
(*  *)

[@@@klogic.type.mangle
[ "int OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicInt>>"
; "string OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicString>>"
; "int OCanren__.Logic.ilogic", "Term<LogicInt>"
; "int OCanren.ilogic", "LogicInt"
; "string OCanren__.Logic.ilogic", "LogicString"
  (* ; ( "(int OCanren__.Logic.ilogic, int OCanren__.Logic.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" )
; ( "(int OCanren.ilogic, int OCanren.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" ) *)
; "jtype_injected", "JType"
; "decl_injected", "Decl"
; "Polarity.t ilogic", "Polarity"
; "jtype_injected OCanren.Std.Option.injected", "Term<LogicOption<JType>>"
; "OCanren.goal", "Goal"
; "Targ.injected", "Jarg"
; "Jtype.injected", "Jtype"
; "Polarity.injected", "Polarity"
; "Polarity.t", "Polarity"
; "OCanren.Std.Pair.injected", "LogicPair"
; "OCanren.Std.Nat.injected", "PeanoLogicNumber"
; "OCanren.Std.Option.injected", "LogicOption"
  (* ; ( "('id OCanren.ilogic, 'id OCanren.ilogic Jtype.injected Targ.injected \
     OCanren.Std.List.injected, OCanren.Std.Nat.injected, 'id OCanren.ilogic \
     Jtype.injected, 'id OCanren.ilogic Jtype.injected OCanren.Std.Option.injected, 'id \
     OCanren.ilogic Jtype.injected OCanren.Std.List.injected)Jtype.t \
     OCanren__.Logic.ilogic"
  , "FUCK" ) *)
]]

(* let conso1 : int ilogic Std.List.injected -> goal =
 fun xs -> fresh (h tl) (xs === Std.List.cons h tl)
;; *)

(* let nilo1 : int ilogic Std.List.injected -> goal = fun xs -> xs === Std.List.nil () *)
(* let nilo2 : int ilogic Std.List.injected -> goal = fun xs -> xs =/= Std.List.cons __ __ *)

(* module type CT = sig
  val decl_by_id : (int ilogic -> OCanren.goal) -> decl_injected -> OCanren.goal

  val get_superclass
    :  (int ilogic -> OCanren.goal)
    -> (int ilogic -> OCanren.goal)
    -> jtype_injected Std.Option.injected
    -> OCanren.goal

  (* val object_t : jtype_injected -> OCanren.goal
     val cloneable_t : jtype_injected -> OCanren.goal
     val serializable_t : jtype_injected -> OCanren.goal *)
  val new_var : (int OCanren.ilogic -> OCanren.goal) -> int ilogic -> OCanren.goal
end

module type STUFF = sig end

module Stuff (Impl : CT) : STUFF = struct
  let not_a_superclass : int ilogic -> int ilogic -> goal =
   fun a b -> Impl.get_superclass (fun x -> x === a) (fun x -> x === b) (Std.none ())
 ;;
end *)

let rec list_ho_map
  :  (('a ilogic -> goal) -> 'b ilogic -> goal) -> ('a ilogic Std.List.injected -> goal)
  -> 'b ilogic Std.List.injected -> goal
  =
 fun f lst ys ->
  fresh
    xs
    (lst xs)
    (conde
       [ xs === Std.nil () &&& (ys === Std.nil ())
       ; fresh
           (h tl tmph tmptl)
           (xs === Std.List.cons h tl)
           (ys === Std.(tmph % tmptl))
           (f (fun eta -> eta === h) tmph)
           (list_ho_map f (fun eta -> eta === tl) tmptl)
       ])
;;

let rec list_ho_nth
  :  ('b ilogic Std.List.injected -> goal) -> (Std.Nat.injected -> goal) -> 'b ilogic
  -> goal
  =
 fun hoxs hon rez ->
  fresh
    (xs n)
    (hoxs xs)
    (hon n)
    (conde
       [ fresh tl (n === Std.Nat.zero) (xs === Std.List.cons rez tl)
       ; fresh
           (prev h tl)
           (n === Std.Nat.succ prev)
           (xs === Std.List.cons h tl)
           (list_ho_nth (fun eta -> eta === tl) (fun eta -> eta === prev) rez)
         (* ; xs === Std.nil () &&& failure *)
       ])
;;

module Polarity = struct
  [%%distrib
  type nonrec ground =
    | Extends
    | Super
  [@@deriving gt ~options:{ show; fmt; gmap }]]
end
[@@skip_from_klogic]

module Targ = struct
  [%%distrib
  type nonrec 'jtype ground =
    | Type of 'jtype
    | Wildcard of (Polarity.ground * 'jtype) Std.Option.ground
  [@@deriving gt ~options:{ show; fmt; gmap }]]

  let type_ t : _ ilogic injected = !!(Type t)
  let wildcard t : _ injected = !!(Wildcard t)
end
[@@skip_from_klogic]

module Jtype = struct
  [%%distrib
  type 'id ground =
    | Array of 'id ground
    | Class of 'id * 'id ground Targ.ground Std.List.ground
    | Interface of 'id * 'id ground Targ.ground Std.List.ground
    | Var of
        { id : 'id
        ; index : Std.Nat.ground
        ; upb : 'id ground
        ; lwb : 'id ground Std.Option.ground
        }
    | Null
    | Intersect of 'id ground Std.List.ground
  [@@deriving gt ~options:{ show; fmt; gmap }]]

  let array a : _ injected = !!(Array a)
  let class_ a b : _ injected = !!(Class (a, b))
  let interface a b : _ injected = !!(Interface (a, b))
  let var id index upb lwb : _ injected = !!(Var { id; index; upb; lwb })
  let intersect a : _ injected = !!(Intersect a)
  let null () : _ injected = !!Null
end
[@@skip_from_klogic]

open Jtype
open Targ
(*
let dummy : 'id ilogic Jtype.injected -> goal =
 fun typ ->
  (* typ === typ *)
  conde
    [ fresh a (typ === array a)
    ; fresh (a b) (typ === class_ a b)
    ; fresh (a b c d) (typ === var a b c d)
    ]
;; *)

let rec substitute_typ :
          'id.
          ('id ilogic Jtype.injected Targ.injected Std.List.injected -> goal)
          -> ('id ilogic Jtype.injected -> goal)
          -> 'id ilogic Jtype.injected
          -> OCanren.goal
  =
 fun subst q0 q30 ->
  fresh
    q3
    (q0 q3)
    (conde
       [ fresh
           (typ q4)
           (q3 === array typ)
           (q30 === array q4)
           (substitute_typ subst (fun eta -> typ === eta) q4)
       ; fresh
           (id args q8)
           (q3 === class_ id args)
           (q30 === class_ id q8)
           (List.HO.map
              (fun a b -> substitute_arg subst a b)
              (fun eta -> eta === args)
              q8)
       ; fresh
           (id args q13)
           (q3 === interface id args)
           (q30 === interface id q13)
           (List.HO.map
              (fun a b -> substitute_arg subst a b)
              (fun eta -> eta === args)
              q13)
       ; fresh
           (typs q17)
           (q3 === intersect typs)
           (q30 === intersect q17)
           (List.HO.map
              (fun a b -> substitute_typ subst a b)
              (fun eta -> eta === typs)
              q17)
         (* ; fresh () (q3 === null ()) (q30 === null ()) *)
       ])

and substitute_arg :
      'id.
      ('id ilogic Jtype.injected Targ.injected Std.List.injected -> goal)
      -> ('id ilogic Jtype.injected Targ.injected -> goal)
      -> 'id ilogic Jtype.injected Targ.injected
      -> goal
  =
 fun subst q34 q63 ->
  fresh
    q37
    (q34 q37)
    (conde
       [ fresh
           (q38 index q39 q40)
           (q37 === type_ (var q38 index q39 q40))
           (List.HO.nth subst (fun eta -> eta === index) q63)
       ; fresh
           (typ q48)
           (q37 === type_ typ)
           (q63 === type_ q48)
           (* (q37 =/= type_ (var __ __ __ __)) *)
           (substitute_typ subst (fun eta -> typ === eta) q48)
       ; fresh
           ()
           (q37 === wildcard (Std.none ()))
           (q63 === wildcard (Std.none ()))
           (q37 =/= type_ __)
           (q37 =/= type_ (var __ __ __ __))
       ; fresh
           (p typ q58 q59)
           (q37 === wildcard (Std.some (Std.pair p typ)))
           (q63 === wildcard (Std.some (Std.pair q58 q59)))
           (p === q58)
           (q37 =/= wildcard (Std.none ()))
           (q37 =/= type_ __)
           (* (q37 =/= type_ (var __ __ __ __)) *)
           (substitute_typ subst (fun eta -> typ === eta) q59)
       ])
;;

module type HIGH_ORDER = sig
  val decl_by_id : (int ilogic -> OCanren.goal) -> decl_injected -> OCanren.goal

  val get_superclass
    :  (int ilogic -> OCanren.goal)
    -> (int ilogic -> OCanren.goal)
    -> int ilogic Jtype.injected Std.Option.injected
    -> OCanren.goal

  val object_t : jtype_injected -> OCanren.goal
  val cloneable_t : jtype_injected -> OCanren.goal
  val serializable_t : jtype_injected -> OCanren.goal
  val new_var : int ilogic -> OCanren.goal
end

module type CLASS_TABLE = sig
  module HO : HIGH_ORDER

  (* val ( <-< )
      :  (jtype_injected -> Option.HO.goal)
      -> (jtype_injected -> Option.HO.goal)
      -> bool ilogic
      -> OCanren.goal *)
end

module type VERIFIER = sig
  val appo : ('a ilogic -> goal) -> 'a ilogic -> goal
end

module Verifier (CT : CLASS_TABLE) : VERIFIER = struct
  let appo : ('a ilogic -> goal) -> 'a ilogic -> goal = fun f x -> f x
end
