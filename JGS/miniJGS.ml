open OCanren

type jtype_injected = int OCanren.ilogic
type decl_injected = int OCanren.ilogic

[@@@klogic.preamble
{|// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName")

package utils.JGS

import org.klogic.core.*
import org.klogic.utils.terms.LogicList
import org.klogic.utils.terms.LogicList.Companion.logicListOf
import org.klogic.utils.terms.Nil.nilLogicList
import org.klogic.utils.terms.plus
import utils.LogicInt
import utils.LogicOption
//import utils.None

typealias Decl = LogicInt
typealias JType = LogicInt

fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }
|}]

[@@@klogic.epilogue {|// Put epilogue here |}]

[@@@klogic.type.mangle
[ "int OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicInt>>"
; "string OCanren.ilogic OCanren.Std.List.injected", "Term<LogicList<LogicString>>"
; "int OCanren__.Logic.ilogic", "Term<LogicInt>"
; "int OCanren.ilogic", "Term<LogicInt>"
; "string OCanren__.Logic.ilogic", "Term<LogicString>"
; ( "(int OCanren__.Logic.ilogic, int OCanren__.Logic.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" )
; ( "(int OCanren.ilogic, int OCanren.ilogic \
     OCanren.Std.List.injected)OCanren.Std.List.t OCanren__.Logic.ilogic"
  , "Term<LogicList<LogicInt>>" )
; "jtype_injected", "Term<JType>"
; "decl_injected", "Term<Decl>"
; "jtype_injected OCanren.Std.Option.injected", "Term<LogicOption<JType>>"
; "OCanren.goal", "Goal"
]]

let conso1 : int ilogic Std.List.injected -> goal =
 fun xs -> fresh (h tl) (xs === Std.List.cons h tl)
;;

let nilo1 : int ilogic Std.List.injected -> goal = fun xs -> xs === Std.List.nil ()
(* let nilo2 : int ilogic Std.List.injected -> goal = fun xs -> xs =/= Std.List.cons __ __ *)

module type CT = sig
  val decl_by_id : (int ilogic -> OCanren.goal) -> decl_injected -> OCanren.goal

  val get_superclass
    :  (int ilogic -> OCanren.goal)
    -> (int ilogic -> OCanren.goal)
    -> jtype_injected Std.Option.injected
    -> OCanren.goal

  (* val object_t : jtype_injected -> OCanren.goal
     val cloneable_t : jtype_injected -> OCanren.goal
     val serializable_t : jtype_injected -> OCanren.goal *)
  val new_var : (int OCanren.ilogic -> OCanren.goal) -> int ilogic -> OCanren.goal
end

module type STUFF = sig end

module Stuff (Impl : CT) : STUFF = struct
  let not_a_superclass : int ilogic -> int ilogic -> goal =
   fun a b -> Impl.get_superclass (fun x -> x === a) (fun x -> x === b) (Std.none ())
 ;;
end
