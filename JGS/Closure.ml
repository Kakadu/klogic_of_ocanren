open OCanren
open JGS

[@@@klogic.preamble
{|// Autogenerated file
@file:Suppress("FunctionName", "NonAsciiCharacters", "TestFunctionName"
  , "PropertyName", "ClassName", "LocalVariableName", "SpellCheckingInspection"
  , "PARAMETER_NAME_CHANGED_ON_OVERRIDE", "NAME_SHADOWING"
  )

package utils.JGS.Closure

import org.klogic.core.*
import org.klogic.utils.terms.*
import org.klogic.utils.terms.LogicBool.Companion.toLogicBool
import org.klogic.utils.terms.Nil.nilLogicList
import utils.LogicInt
import utils.LogicInt.Companion.toLogic

import utils.JGS.*
import utils.JGS.Var
import utils.Some
import utils.None
import utils.LogicOption

@Suppress("UNCHECKED_CAST")
fun <T: Term<T>> None(): LogicOption<T> = utils.None as LogicOption<T>

context(RelationalContext)
fun  pause(f: () -> Goal): Goal = { st -> ThunkStream { f()(st) } }
|}]

[@@@klogic.epilogue {|// Put epilogue here |}]

(*  *)
[@@@klogic.ident.mangle
[ "JGS.Jtype.array", "Array_"
; "JGS.Jtype.class_", "Class_"
; "JGS.Jtype.interface", "Interface"
; "JGS.Jtype.var", "Var"
; "JGS.Jtype.null", "Null"
; "JGS.Jtype.intersect", "Intersect"
; "JGS.Decl.c", "C"
; "JGS.Decl.i", "I"
; "OCanren.Std.some", "Some"
; "JGS_Helpers.only_classes_interfaces_and_arrays", "only_classes_interfaces_and_arrays"
]]

(*  *)
[@@@klogic.type.mangle [ "JGS.Targ.injected", "Jarg"; "JGS.Jtype.injected", "Jtype" ]]

let rec list_same_length :
  'a ilogic Std.List.injected -> 'b ilogic Std.List.injected -> goal
  =
 fun xs ys ->
  let open Std in
  conde
    [ fresh (h1 h2 tl1 tl2) (xs === h1 % tl1) (ys === h2 % tl2) (list_same_length tl1 tl2)
    ; fresh () (xs === nil ()) (ys === nil ())
    ]
;;

module type CLOSURE = sig
  val direct_subtyping :
     (int ilogic Jtype.injected -> goal -> goal -> goal)
    -> ((int ilogic Jtype.injected -> int ilogic Jtype.injected -> bool ilogic -> goal)
        -> int ilogic Jtype.injected
        -> int ilogic Jtype.injected
        -> bool ilogic
        -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal

  val closure :
     (int ilogic Jtype.injected -> goal -> goal -> goal)
    -> ((int ilogic Jtype.injected -> int ilogic Jtype.injected -> bool ilogic -> goal)
        -> int ilogic Jtype.injected
        -> int ilogic Jtype.injected
        -> bool ilogic
        -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal

  (** Functions [is_correct_type], [(-<-)], [( <-< )] are not required to be public for OCaml,
      but the way we put 'override' identifier in Kotlin requires making it visible *)
  val is_correct_type :
     (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> int ilogic Jtype.injected
    -> goal

  val ( -<- ) :
     ((int ilogic Jtype.injected -> int ilogic Jtype.injected -> bool ilogic -> goal)
      -> int ilogic Jtype.injected
      -> int ilogic Jtype.injected
      -> bool ilogic
      -> goal)
    -> (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> (int ilogic Jtype.injected -> goal)
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal

  val ( >-> ) :
     (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal

  val ( <-< ) :
     (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal

  val ( <-> ) :
     (int ilogic Jtype.injected -> goal -> goal -> goal)
    -> (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal
end

module Closure (CT : CLASSTABLE) : CLOSURE = struct
  let is_correct_type :
     (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> int ilogic Jtype.injected
    -> goal
    =
   fun closure_subtyping t ->
    conde
      [ (* Array: always allow *)
        fresh elems (t === Jtype.array elems)
      ; (* Class: should be metioned in class declarations with the same arguments amount *)
        fresh
          (id actual_params expected_params super_ supers)
          (t === Jtype.class_ id actual_params)
          (CT.decl_by_id id (Decl.c expected_params super_ supers))
          (list_same_length expected_params actual_params)
      ; (* Interface: should be metioned in interface declarations with the same arguments amount *)
        fresh
          (id actual_params expected_params supers)
          (t === Jtype.interface id actual_params)
          (CT.decl_by_id id (Decl.i expected_params supers))
          (list_same_length expected_params actual_params)
      ; (* Variable: lower bound should be subtype of upper bound *)
        fresh
          (id index upb lwb)
          (t === Jtype.var id index upb (Std.some lwb))
          (upb =/= lwb)
          (closure_subtyping lwb upb)
      ; (* Varaible without lover bound: always allow *)
        fresh (id index upb) (t === Jtype.var id index upb (Std.none ()))
      ; (* Null: always allow *)
        t === Jtype.null ()
      ; (* Intersect: always allow *)
        fresh args (t === Jtype.intersect args)
      ]
  ;;

  let ( -<- ) :
     ((int ilogic Jtype.injected -> int ilogic Jtype.injected -> bool ilogic -> goal)
      -> int ilogic Jtype.injected
      -> int ilogic Jtype.injected
      -> bool ilogic
      -> goal)
    -> (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> (int ilogic Jtype.injected -> goal)
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal
    =
   fun open_direct_subtyping closure_subtyping is_correct_type ta tb ->
    fresh
      ()
      (open_direct_subtyping
         (fun a b rez -> fresh () (rez === !!true) (closure_subtyping a b))
         ta
         tb
         !!true)
      (is_correct_type ta)
      (is_correct_type tb)
  ;;

  let rec ( <-< ) :
     (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal
    =
   fun direct_subtyping query_constr ta tb ->
    fresh
      ()
      query_constr
      (JGS_Helpers.only_classes_interfaces_and_arrays ta)
      (JGS_Helpers.only_classes_interfaces_and_arrays tb)
      (conde
         [ direct_subtyping ta tb
         ; fresh
             ti
             (tb =/= ti)
             (ta =/= ti)
             (ta =/= tb)
             (JGS_Helpers.only_classes_interfaces_and_arrays ti)
             (direct_subtyping ti tb)
             (( <-< ) direct_subtyping query_constr ta ti)
         ])
  ;;

  let rec ( >-> ) :
     (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal
    =
   fun direct_subtyping query_constr ta tb ->
    fresh
      ()
      query_constr
      (JGS_Helpers.only_classes_interfaces_and_arrays ta)
      (JGS_Helpers.only_classes_interfaces_and_arrays tb)
      (conde
         [ direct_subtyping ta tb
         ; fresh
             ti
             (tb =/= ti)
             (ta =/= ti)
             (ta =/= tb)
             (JGS_Helpers.only_classes_interfaces_and_arrays ti)
             (direct_subtyping ta ti)
             (( >-> ) direct_subtyping query_constr ti tb)
         ])
  ;;

  let ( <-> ) :
     (int ilogic Jtype.injected -> goal -> goal -> goal)
    -> (int ilogic Jtype.injected -> int ilogic Jtype.injected -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal
    =
   (* `debug_var_handler` is abstraction for `debug_var` with pattern matching of reified value.
      `debug_var_handler` should be:

  let debug_var_handler : int ilogic Jtype.injected -> goal -> goal -> goal =
   fun ta closure_down closure_up ->
    debug_var ta
      (Fun.flip (Jtype.reify OCanren.reify))
      (fun reified_ta ->
        match reified_ta with [ Value _ ] -> closure_up | _ -> closure_down)
   *)
   fun debug_var_handler direct_subtyping query_constr ta tb ->
    debug_var_handler
      ta
      (( <-< ) direct_subtyping query_constr ta tb)
      (( >-> ) direct_subtyping query_constr ta tb)
  ;;

  let rec direct_subtyping :
     (int ilogic Jtype.injected -> goal -> goal -> goal)
    -> ((int ilogic Jtype.injected -> int ilogic Jtype.injected -> bool ilogic -> goal)
        -> int ilogic Jtype.injected
        -> int ilogic Jtype.injected
        -> bool ilogic
        -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal
    =
   fun debug_var_handler open_direct_subtyping query_constr ta tb ->
    ( -<- )
      open_direct_subtyping
      (fun ta tb -> closure debug_var_handler open_direct_subtyping query_constr ta tb)
      (fun eta ->
        is_correct_type
          (fun ta tb ->
            closure debug_var_handler open_direct_subtyping query_constr ta tb)
          eta)
      ta
      tb

  and closure :
     (int ilogic Jtype.injected -> goal -> goal -> goal)
    -> ((int ilogic Jtype.injected -> int ilogic Jtype.injected -> bool ilogic -> goal)
        -> int ilogic Jtype.injected
        -> int ilogic Jtype.injected
        -> bool ilogic
        -> goal)
    -> goal
    -> int ilogic Jtype.injected
    -> int ilogic Jtype.injected
    -> goal
    =
   fun debug_var_handler open_direct_subtyping query_constr ta tb ->
    ( <-> )
      debug_var_handler
      (fun ta tb ->
        direct_subtyping debug_var_handler open_direct_subtyping query_constr ta tb)
      query_constr
      ta
      tb
  ;;
end
